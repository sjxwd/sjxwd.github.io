<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Pandas基础</title>
    <link href="/2024/03/28/Pandas%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/03/28/Pandas%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="一、对象的创建"><a href="#一、对象的创建" class="headerlink" title="一、对象的创建"></a>一、对象的创建</h2><h3 id="1-一维对象的创建-pd-Serise"><a href="#1-一维对象的创建-pd-Serise" class="headerlink" title="1. 一维对象的创建    pd.Serise()"></a>1. 一维对象的创建    <code>pd.Serise()</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#字典创建法</span><br>dict_v = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">0.25</span>,<span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">0.5</span>,<span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">0.75</span>,<span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">1</span>&#125;<br>dict_v<br>sr = pd.Series(dict_v) <span class="hljs-comment"># 用字典创建pandas一维对象</span><br><span class="hljs-built_in">print</span>(sr)<br><br><span class="hljs-comment"># 数组创建法</span><br>v = np.array([<span class="hljs-number">0</span>,<span class="hljs-number">0.25</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.5</span>]) <span class="hljs-comment"># v可以是列表、数组、张量</span><br>v = [<span class="hljs-number">0</span>,<span class="hljs-number">0.25</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.5</span>]<br>v = torch.tensor([<span class="hljs-number">0</span>,<span class="hljs-number">0.25</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.5</span>])<br>k = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>]<br>sr = pd.Series(v,index=k) <span class="hljs-comment"># 用关键字创建pandas一维对象</span><br>sr = pd.Series(v) <span class="hljs-comment"># 若省略关键字，则索引变为由0开始的顺序数字</span><br><span class="hljs-built_in">print</span>(sr.values) <span class="hljs-comment"># 不论用数组、列表和张量创建对象，values都是数组</span><br><span class="hljs-built_in">print</span>(sr.index)<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403281820037.png"></p><p><strong>注意：可见，虽然 Pandas 对象的第一个参数 values 可以传入列表、数组与张量，但传进去后默认的存储方式是 NumPy 数组。这一点更加提醒我们，Pandas 是建立在 NumPy 基础上的库，没有 NumPy 数组库就没有 Pandas 数据处理库。而如果我们想要 Pandas 退化为 NumPy 时，调用其 values 属性即可。</strong></p><h3 id="2-二维数组的创建-pd-DataFrame"><a href="#2-二维数组的创建-pd-DataFrame" class="headerlink" title="2. 二维数组的创建   pd.DataFrame()"></a>2. 二维数组的创建   <code>pd.DataFrame</code>()</h3><p>二维对象将面向矩阵，其不仅有行标签 index，还有列标签 columns。<br>用字典法创建二维对象时，必须基于多个 Series 对象，每一个 Series 就是一列数据，相当于对一列一列的数据作拼接。<br>⚫ 创建 Series 对象时，字典的键是 index，其延展方向是竖直方向；<br>⚫ 创建 DataFrame 对象时，字典的键是 columns，其延展方向是水平方向。</p><ul><li><h4 id="字典创建法"><a href="#字典创建法" class="headerlink" title="字典创建法"></a>字典创建法</h4></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">v1 = [ <span class="hljs-number">53</span>, <span class="hljs-number">64</span>, <span class="hljs-number">72</span>, <span class="hljs-number">82</span> ]<br>i = [ <span class="hljs-string">&#x27;1 号&#x27;</span>, <span class="hljs-string">&#x27;2 号&#x27;</span>, <span class="hljs-string">&#x27;3 号&#x27;</span>, <span class="hljs-string">&#x27;4 号&#x27;</span> ]<br>sr1 = pd.Series(v1,index=i)<br>v2 = [ <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span> ]<br>i = [ <span class="hljs-string">&#x27;1 号&#x27;</span>, <span class="hljs-string">&#x27;2 号&#x27;</span>, <span class="hljs-string">&#x27;3 号&#x27;</span>, <span class="hljs-string">&#x27;4 号&#x27;</span> ]<br>sr2 = pd.Series(v2,index=i)<br>sr3 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;年龄&#x27;</span>:sr1,<span class="hljs-string">&#x27;性别&#x27;</span>:sr2&#125;)<span class="hljs-comment"># 创建二维对象，按列拼接</span><br><span class="hljs-built_in">print</span>(sr3)<br><br><span class="hljs-comment"># 如果 sr1 和 sr2 的 index 不完全一致，那么二维对象的 index 会取 sr1 与 sr2的所有 index，相应的，该对象就会产生一定数量的缺失值（NaN）</span><br>v1 = [ <span class="hljs-number">53</span>, <span class="hljs-number">64</span>, <span class="hljs-number">72</span>, <span class="hljs-number">82</span> ]<br>i = [ <span class="hljs-string">&#x27;1 号&#x27;</span>, <span class="hljs-string">&#x27;2 号&#x27;</span>, <span class="hljs-string">&#x27;3 号&#x27;</span>, <span class="hljs-string">&#x27;4 号&#x27;</span> ]<br>sr1 = pd.Series(v1,index=i)<br>v2 = [ <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span> ]<br>i = [ <span class="hljs-string">&#x27;1 号&#x27;</span>, <span class="hljs-string">&#x27;2 号&#x27;</span>, <span class="hljs-string">&#x27;3 号&#x27;</span>, <span class="hljs-string">&#x27;6 号&#x27;</span> ]<br>sr2 = pd.Series(v2,index=i)<br>sr3 = pd.DataFrame(&#123;<span class="hljs-string">&#x27;年龄&#x27;</span>:sr1,<span class="hljs-string">&#x27;性别&#x27;</span>:sr2&#125;)<span class="hljs-comment"># 创建二维对象，按列拼接</span><br><span class="hljs-built_in">print</span>(sr3)<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403281827039.png"></p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403281827017.png"></p><ul><li><h4 id="数组创建法"><a href="#数组创建法" class="headerlink" title="数组创建法"></a>数组创建法</h4></li></ul><p>最直接的创建方法即直接给 pd.DataFrame 函数参数，其需要三个参数。第一个参数是值 values（数组），第二个参数是行标签 index，第三个参数是列标签columns。其中，index 和 columns 参数可以省略，省略后即从 0 开始的顺序数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">v = np.array( [ [<span class="hljs-number">53</span>, <span class="hljs-string">&#x27;女&#x27;</span>], [<span class="hljs-number">64</span>, <span class="hljs-string">&#x27;男&#x27;</span>], [<span class="hljs-number">72</span>, <span class="hljs-string">&#x27;男&#x27;</span>], [<span class="hljs-number">82</span>, <span class="hljs-string">&#x27;女&#x27;</span>] ] ) <span class="hljs-comment"># 二维数组</span><br>i = [ <span class="hljs-string">&#x27;1 号&#x27;</span>, <span class="hljs-string">&#x27;2 号&#x27;</span>, <span class="hljs-string">&#x27;3 号&#x27;</span>, <span class="hljs-string">&#x27;4 号&#x27;</span> ] <span class="hljs-comment"># 行标签</span><br>c = [ <span class="hljs-string">&#x27;年龄&#x27;</span>, <span class="hljs-string">&#x27;性别&#x27;</span> ] <span class="hljs-comment"># 列标签</span><br>df = pd.DataFrame(v,index=i,columns=c)<br></code></pre></td></tr></table></figure><p><strong>注意：第二行的 NumPy 数组居然又含数字又含字符串，但是数组只能容纳一种变量类型。这里的原理是，数组默默把数字转为了字符串，于是 v 就是一个字符串型数组。而当我们想要 Pandas 退化为 NumPy 时，查看其 values 属性并提取即可。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">df.values<br>df.index<br>df.columns<br>arr = df.values<br><span class="hljs-comment"># 提取第[0]列，并转化为一个整数型数组</span><br>arr = arr[:,<span class="hljs-number">0</span>].astype(<span class="hljs-built_in">int</span>) <br></code></pre></td></tr></table></figure><p><strong>注意：由于数组只能容纳一种变量类型，因此需要 .astype(int) 的操作转换为整型后才能进行计算。但对象不用，对象每一列的存储方式是单独的，所以每一列可以单独拿出来直接进行计算。</strong></p><h2 id="二、对象的索引-pd-loc-pd-iloc"><a href="#二、对象的索引-pd-loc-pd-iloc" class="headerlink" title="二、对象的索引 pd.loc()   pd.iloc()"></a>二、对象的索引 <code>pd.loc()</code>   <code>pd.iloc()</code></h2><p>⚫ Pandas 的索引分为显式索引与隐式索引。显式索引是使用 Pandas 对象提 供的索引，而隐式索引是使用数组本身自带的从 0 开始的索引。</p><p>⚫ 现假设某演示代码中的索引是整数，这个时候显式索引和隐式索引可能 会出乱子。于是，Pandas 作者发明了索引器 loc（显式）与 iloc（隐式）,手动告诉程序自己这句话是显式索引还是隐式索引。</p><h3 id="1-一维对象的索引"><a href="#1-一维对象的索引" class="headerlink" title="1. 一维对象的索引"></a>1. 一维对象的索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">v = [<span class="hljs-number">53</span>,<span class="hljs-number">25</span>,<span class="hljs-number">64</span>,<span class="hljs-number">78</span>]<br>k = [<span class="hljs-string">&#x27;1号&#x27;</span>,<span class="hljs-string">&#x27;2号&#x27;</span>,<span class="hljs-string">&#x27;3号&#x27;</span>,<span class="hljs-string">&#x27;4号&#x27;</span>]<br>sr = pd.Series(v,index=k)<br>sr[<span class="hljs-string">&#x27;3号&#x27;</span>] = <span class="hljs-number">18</span> <span class="hljs-comment"># 访问并修改元素</span><br>sr[[<span class="hljs-string">&#x27;1号&#x27;</span>,<span class="hljs-string">&#x27;3号&#x27;</span>]] <span class="hljs-comment"># 花式索引</span><br>sr.loc[<span class="hljs-string">&#x27;3号&#x27;</span>] <span class="hljs-comment"># 显式索引访问3号对于的元素(这里与隐式索引不会混淆也可以直接用sr[])</span><br>sr.iloc[<span class="hljs-number">2</span>] <span class="hljs-comment"># 隐式索引访问3号对应的元素</span><br><br><span class="hljs-comment"># 访问元素</span><br>v = [<span class="hljs-number">53</span>,<span class="hljs-number">25</span>,<span class="hljs-number">64</span>,<span class="hljs-number">78</span>]<br>k = [<span class="hljs-string">&#x27;1号&#x27;</span>,<span class="hljs-string">&#x27;2号&#x27;</span>,<span class="hljs-string">&#x27;3号&#x27;</span>,<span class="hljs-string">&#x27;4号&#x27;</span>]<br>sr = pd.Series(v,index=k)<br>sr.loc[<span class="hljs-string">&#x27;1号&#x27;</span>:<span class="hljs-string">&#x27;3号&#x27;</span>] <span class="hljs-comment"># 注意：这里显示索引会包含最后一项，是左闭右闭的(不同于隐式索引)</span><br>sr.iloc[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>] <span class="hljs-comment"># 隐式索引是左闭右开的</span><br>sr[<span class="hljs-string">&#x27;1号&#x27;</span>:<span class="hljs-string">&#x27;3号&#x27;</span>][<span class="hljs-string">&#x27;1号&#x27;</span>] = <span class="hljs-number">100</span> <span class="hljs-comment"># 切片只是视图，会改变原先的对象</span><br>cut = sr<br>cut[<span class="hljs-string">&#x27;1号&#x27;</span>] = <span class="hljs-number">200</span> <span class="hljs-comment"># 赋值只是绑定，会改变原对象</span><br><span class="hljs-comment"># 若想创建新变量，与 NumPy 一样，使用.copy()方法即可</span><br></code></pre></td></tr></table></figure><h3 id="2-二维对象的索引"><a href="#2-二维对象的索引" class="headerlink" title="2. 二维对象的索引"></a>2. 二维对象的索引</h3><p><strong>注意：在二维对象中，索引器不能去掉，否则会报错，因此必须适应索引器的存在。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二维对象必须加索引器</span><br>v1 = [ <span class="hljs-number">53</span>, <span class="hljs-number">64</span>, <span class="hljs-number">72</span>, <span class="hljs-number">82</span> ]<br>i = [ <span class="hljs-string">&#x27;1号&#x27;</span>, <span class="hljs-string">&#x27;2号&#x27;</span>, <span class="hljs-string">&#x27;3号&#x27;</span>, <span class="hljs-string">&#x27;4号&#x27;</span> ]<br>sr1 = pd.Series(v1,index=i)<br>v2 = [ <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span> ]<br>i = [ <span class="hljs-string">&#x27;1号&#x27;</span>, <span class="hljs-string">&#x27;2号&#x27;</span>, <span class="hljs-string">&#x27;3号&#x27;</span>, <span class="hljs-string">&#x27;4号&#x27;</span> ]<br>sr2 = pd.Series(v2,index=i)<br>df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;年龄&#x27;</span>:sr1,<span class="hljs-string">&#x27;性别&#x27;</span>:sr2&#125;)<br>df.loc[<span class="hljs-string">&#x27;3号&#x27;</span>, <span class="hljs-string">&#x27;年龄&#x27;</span>]  <span class="hljs-comment"># 显式索引</span><br>df.loc[[<span class="hljs-string">&#x27;1号&#x27;</span>,<span class="hljs-string">&#x27;3号&#x27;</span>],[<span class="hljs-string">&#x27;性别&#x27;</span>,<span class="hljs-string">&#x27;年龄&#x27;</span>]] <span class="hljs-comment"># 花式索引，输出为一个包含行与列的对象</span><br>df.iloc[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] <span class="hljs-comment"># 隐式索引</span><br>df.loc[:,<span class="hljs-string">&#x27;年龄&#x27;</span>] <span class="hljs-comment"># 显示提取列</span><br>df.iloc[:,<span class="hljs-number">0</span>] <span class="hljs-comment"># 隐式提取列</span><br>df[<span class="hljs-string">&#x27;年龄&#x27;</span>] <span class="hljs-comment"># 提取列</span><br></code></pre></td></tr></table></figure><p>在 NumPy 数组中，花式索引输出的是一个向量。但在 Pandas 对象中，考虑到其行列标签的信息不能丢失，所以输出一个向量就不行了，所以这里才输出一个二维对象。</p><p>花式索引结果：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403281926823.png"></p><p><strong>注意：在显示索引中，提取矩阵的行或列还有一种简便写法，即</strong> ：</p><p><strong>⚫ 提取二维对象的行：df.loc[ ‘3 号’] （原理是省略后面的冒号，隐式也可以）</strong> </p><p><strong>⚫ 提取二维对象的列：df [‘年龄’ ]（原理是列标签本身就是二维对象的键）</strong></p><h2 id="三、对象的变形"><a href="#三、对象的变形" class="headerlink" title="三、对象的变形"></a>三、对象的变形</h2><h3 id="1-转置与翻转"><a href="#1-转置与翻转" class="headerlink" title="1. 转置与翻转"></a>1. 转置与翻转</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">v = [ [<span class="hljs-number">53</span>, <span class="hljs-number">64</span>, <span class="hljs-number">72</span>, <span class="hljs-number">82</span>], [ <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span> ] ]<br>i = [ <span class="hljs-string">&#x27;年龄&#x27;</span>, <span class="hljs-string">&#x27;性别&#x27;</span> ]<br>c = [ <span class="hljs-string">&#x27;1 号&#x27;</span>, <span class="hljs-string">&#x27;2 号&#x27;</span>, <span class="hljs-string">&#x27;3 号&#x27;</span>, <span class="hljs-string">&#x27;4 号&#x27;</span> ]<br>df = pd.DataFrame( v, index=i, columns=c )<br>df<br>df = df.T <span class="hljs-comment">#转置</span><br>df.iloc[:,::-<span class="hljs-number">1</span>] <span class="hljs-comment"># 左右反转，取全部的行，取全部的列，列从最后一项采样所以步长为-1</span><br>df.iloc[::-<span class="hljs-number">1</span>,:] <span class="hljs-comment"># 上下反转，取全部的列，取全部的行，行从最后一项采样所以步长为-1</span><br></code></pre></td></tr></table></figure><h3 id="2-重塑"><a href="#2-重塑" class="headerlink" title="2. 重塑"></a>2. 重塑</h3><p>考虑到对象是含有行列标签的，.reshape()已不再适用，因此对象的重塑没有 那么灵活。但可以做到将 sr 并入 df，也可以将 df 割出 sr。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">i = [ <span class="hljs-string">&#x27;1 号&#x27;</span>, <span class="hljs-string">&#x27;2 号&#x27;</span>, <span class="hljs-string">&#x27;3 号&#x27;</span>, <span class="hljs-string">&#x27;4 号&#x27;</span> ]<br>v1 = [ <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span> ]<br>v2 = [ <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span> ]<br>v3 = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> ]<br>sr1 = pd.Series( v1, index=i )<br>sr2 = pd.Series( v2, index=i )<br>sr3 = pd.Series( v3, index=i )<br>df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;年龄&#x27;</span>:sr1,<span class="hljs-string">&#x27;性别&#x27;</span>:sr2&#125;)<br>df[<span class="hljs-string">&#x27;牌照&#x27;</span>] = sr3 <span class="hljs-comment"># 写入一列</span><br>sr4 = df[<span class="hljs-string">&#x27;年龄&#x27;</span>] <span class="hljs-comment"># 抽出一列</span><br></code></pre></td></tr></table></figure><h3 id="3-拼接-pd-concat"><a href="#3-拼接-pd-concat" class="headerlink" title="3. 拼接   pd.concat()"></a>3. 拼接   <code>pd.concat()</code></h3><p>Pandas 中有一个 pd.concat()函数，与 np.concatenate()函数语法相似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 一维对象的拼接</span><br>v1 = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>]<br>v2 = [<span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>]<br>k1 = [ <span class="hljs-string">&#x27;1 号&#x27;</span>, <span class="hljs-string">&#x27;2 号&#x27;</span>, <span class="hljs-string">&#x27;3 号&#x27;</span>, <span class="hljs-string">&#x27;4 号&#x27;</span> ]<br>k2 = [ <span class="hljs-string">&#x27;4 号&#x27;</span>, <span class="hljs-string">&#x27;5 号&#x27;</span>, <span class="hljs-string">&#x27;6 号&#x27;</span> ]<br>sr1 = pd.Series( v1, index= k1 )<br>sr2 = pd.Series( v2, index= k2 )<br>sr3 = pd.concat([sr1,sr2]) <span class="hljs-comment"># 拼接</span><br>sr3.index<br>sr3.index.is_unique<br><br><span class="hljs-comment"># 一维对象与二维对象的拼接</span><br>df[<span class="hljs-string">&#x27;牌照&#x27;</span>] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] <span class="hljs-comment"># 看作是写入一列</span><br>df.loc[<span class="hljs-string">&#x27;4号&#x27;</span>] = [<span class="hljs-number">30</span>,<span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-number">5</span>] <span class="hljs-comment"># 看作是写入一列</span><br><br><span class="hljs-comment"># 二维对象拼接</span><br>v1 = [ [<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;女&#x27;</span>], [<span class="hljs-number">20</span>, <span class="hljs-string">&#x27;男&#x27;</span>], [<span class="hljs-number">30</span>, <span class="hljs-string">&#x27;男&#x27;</span>], [<span class="hljs-number">40</span>, <span class="hljs-string">&#x27;女&#x27;</span>] ]<br>v2 = [ [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;是&#x27;</span>], [<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;是&#x27;</span>], [<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;是&#x27;</span>], [<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;否&#x27;</span>] ]<br>v3 = [ [<span class="hljs-number">50</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;是&#x27;</span>], [<span class="hljs-number">60</span>, <span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;是&#x27;</span>] ]<br>i1 = [ <span class="hljs-string">&#x27;1 号&#x27;</span>, <span class="hljs-string">&#x27;2 号&#x27;</span>, <span class="hljs-string">&#x27;3 号&#x27;</span>, <span class="hljs-string">&#x27;4 号&#x27;</span> ]<br>i2 = [ <span class="hljs-string">&#x27;1 号&#x27;</span>, <span class="hljs-string">&#x27;2 号&#x27;</span>, <span class="hljs-string">&#x27;3 号&#x27;</span>, <span class="hljs-string">&#x27;4 号&#x27;</span> ]<br>i3 = [ <span class="hljs-string">&#x27;5 号&#x27;</span>, <span class="hljs-string">&#x27;6 号&#x27;</span> ]<br>c1 = [ <span class="hljs-string">&#x27;年龄&#x27;</span>, <span class="hljs-string">&#x27;性别&#x27;</span> ]<br>c2 = [ <span class="hljs-string">&#x27;牌照&#x27;</span>, <span class="hljs-string">&#x27;ikun&#x27;</span> ]<br>c3 = [ <span class="hljs-string">&#x27;年龄&#x27;</span>, <span class="hljs-string">&#x27;性别&#x27;</span>, <span class="hljs-string">&#x27;牌照&#x27;</span>, <span class="hljs-string">&#x27;ikun&#x27;</span> ]<br>df1 = pd.DataFrame( v1, index=i1, columns=c1 )<br>df2 = pd.DataFrame( v2, index=i2, columns=c2 )<br>df3 = pd.DataFrame( v3, index=i3, columns=c3 )<br>df4 = pd.concat([df1,df2],axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># 按列合并</span><br>df5 = pd.concat([df4,df3],axis=<span class="hljs-number">0</span>) <span class="hljs-comment"># 按行合并</span><br></code></pre></td></tr></table></figure><p>一维对象拼接结果：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403282009776.png"></p><p><strong>注意：一维对象拼接的键中出现了两个“4 号”，这是因为 Pandas 对象的属性，放弃了集合与字典索引中“不可重复”的特性，实际中，这可以拓展大数据分析与处理的应用场景。那么，如何保证索引是不重复的呢？对对象的属 性 .index 或 .columns 使用 .is_unique 即可检查，返回 True表示行或列不重复， False 表示有重复。</strong></p><h2 id="四、对象的运算"><a href="#四、对象的运算" class="headerlink" title="四、对象的运算"></a>四、对象的运算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df[<span class="hljs-string">&#x27;年龄&#x27;</span>] = df[<span class="hljs-string">&#x27;年龄&#x27;</span>] + <span class="hljs-number">10</span> <span class="hljs-comment"># 单独拿出一列可以直接进行计算</span><br>sr1 + sr2 <span class="hljs-comment"># 对象与对象直接可以直接运算，但必须保证其都是数字型对象，两个对象之间的维度可以不同，             不是共同拥有的一列的结果会出现Nan</span><br>df1[<span class="hljs-string">&#x27;加法&#x27;</span>] = df1[<span class="hljs-string">&#x27;年龄&#x27;</span>] + df2[<span class="hljs-string">&#x27;牌照&#x27;</span>] <span class="hljs-comment"># 二维对象直接的运算，赋值给一个新列</span><br></code></pre></td></tr></table></figure><p><strong>⚫ 使用 np.abs()、np.cos()、np.exp()、np.log() 等数学函数时，会保留索引；</strong> </p><p><strong>⚫ Pandas 中仍然存在布尔型对象，用法与 NumPy 无异，会保留索引。</strong></p><h2 id="五、对象的缺失值"><a href="#五、对象的缺失值" class="headerlink" title="五、对象的缺失值"></a>五、对象的缺失值</h2><p> 缺失值的查找，剔除和替换  <code>self.isnull</code>  <code>self.dropna</code>   <code>self.fillna</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 缺失值</span><br><span class="hljs-comment"># 创建 sr</span><br>v = [ <span class="hljs-number">53</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">72</span>, <span class="hljs-number">82</span> ]<br>k = [<span class="hljs-string">&#x27;1 号&#x27;</span>, <span class="hljs-string">&#x27;2 号&#x27;</span>, <span class="hljs-string">&#x27;3 号&#x27;</span>, <span class="hljs-string">&#x27;4 号&#x27;</span>]<br>sr = pd.Series( v, index=k )<br>sr<br><span class="hljs-comment"># 创建 df</span><br>v = [ [<span class="hljs-literal">None</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">64</span>, <span class="hljs-literal">None</span>], [<span class="hljs-number">72</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">82</span>, <span class="hljs-number">4</span>] ]<br>i = [ <span class="hljs-string">&#x27;1 号&#x27;</span>, <span class="hljs-string">&#x27;2 号&#x27;</span>, <span class="hljs-string">&#x27;3 号&#x27;</span>, <span class="hljs-string">&#x27;4 号&#x27;</span> ]<br>c = [ <span class="hljs-string">&#x27;年龄&#x27;</span>, <span class="hljs-string">&#x27;牌照&#x27;</span> ]<br>df = pd.DataFrame( v, index=i, columns=c )<br>df<br><span class="hljs-comment"># 一维对象</span><br>sr.isnull() <span class="hljs-comment"># 查找缺失值，并返回布尔值</span><br>~sr.isnull() <span class="hljs-comment"># 查找不是缺失值的，并返回布尔值</span><br>sr.dropna() <span class="hljs-comment"># 剔除缺失值</span><br>sr.fillna(<span class="hljs-number">0</span>) <span class="hljs-comment"># 将0填充到缺失值中</span><br>sr.fillna(np.mean(sr)) <span class="hljs-comment"># 将平均值填充到nan中</span><br>sr.fillna(method=<span class="hljs-string">&#x27;ffill&#x27;</span>) <span class="hljs-comment"># 用nan值的前一个数据填充nan</span><br>sr.fillna(method=<span class="hljs-string">&#x27;bfill&#x27;</span>) <span class="hljs-comment"># 用nan值的后一个数据填充nan</span><br><span class="hljs-comment"># 二维对象</span><br>df.isnull()<br>~df.isnull()<br>df.dropna() <span class="hljs-comment"># 剔除有缺失值的行</span><br>df.dropna(axis = <span class="hljs-number">1</span>) <span class="hljs-comment"># 剔除有缺失值的列，但一般不这样做，列比较重要，不能随意剔除</span><br>df.dropna(how=<span class="hljs-string">&#x27;all&#x27;</span>) <span class="hljs-comment"># 行全为NAN的时候才会剔除行</span><br>df.fillna(np.mean(df))<br></code></pre></td></tr></table></figure><h2 id="六、数据读取"><a href="#六、数据读取" class="headerlink" title="六、数据读取"></a>六、数据读取</h2><p>首先，创建 Excel 文件，录入信息，第一列为 index，第一行为 columns。如果你的数据没有 index 和 columns，也即你只是想导入一个数组，那么也请先补上行列标签，后续用 .values 属性就能将二维对象转换为数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>os.getcwd() <span class="hljs-comment"># 获得当前工作路径的地址</span><br><span class="hljs-comment"># 先将文件再次另存为utf-8的csv文件后，导入到当前工作路径中</span><br>df = pd.read_csv(<span class="hljs-string">&#x27;Data.csv&#x27;</span>,index_col=<span class="hljs-number">0</span>) <span class="hljs-comment"># 第一列为index值</span><br>df = pd.read_csv(<span class="hljs-string">&#x27;Data.csv&#x27;</span>,header=<span class="hljs-literal">None</span>) <span class="hljs-comment"># 取消第一行作为表头</span><br>arr = df.values <span class="hljs-comment"># 直接提取纯数组，去掉了表头和索引值</span><br></code></pre></td></tr></table></figure><h2 id="七、数据分析"><a href="#七、数据分析" class="headerlink" title="七、数据分析"></a>七、数据分析</h2><h3 id="1-描述方法"><a href="#1-描述方法" class="headerlink" title="1. 描述方法"></a>1. 描述方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.read_csv(<span class="hljs-string">&#x27;Data.csv&#x27;</span>,index_col=<span class="hljs-number">0</span>)<br>df.head() <span class="hljs-comment"># 仅输出前五行</span><br>df.<span class="hljs-built_in">max</span>()<br>df.std()<br>df.<span class="hljs-built_in">sum</span>() <span class="hljs-comment"># 聚合函数</span><br>df.describe() <span class="hljs-comment"># 查看所有聚合函数的信息</span><br></code></pre></td></tr></table></figure><h3 id="2-数据透视"><a href="#2-数据透视" class="headerlink" title="2. 数据透视"></a>2. 数据透视</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数据透视</span><br>df = pd.read_csv(<span class="hljs-string">&#x27;泰坦尼克.csv&#x27;</span>, index_col=<span class="hljs-number">0</span>)<br>df.head()<br><span class="hljs-comment"># 一个特征：性别</span><br>df.pivot_table(<span class="hljs-string">&#x27;是否生还&#x27;</span>, index=<span class="hljs-string">&#x27;性别&#x27;</span>)<br><span class="hljs-comment"># 两个特征：性别、船舱等级</span><br>df.pivot_table(<span class="hljs-string">&#x27;是否生还&#x27;</span>, index=<span class="hljs-string">&#x27;性别&#x27;</span>, columns=<span class="hljs-string">&#x27;船舱等级&#x27;</span>)<br><span class="hljs-comment"># 三个特征：性别、船舱等级、年龄</span><br>age = pd.cut( df[<span class="hljs-string">&#x27;年龄&#x27;</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">18</span>,<span class="hljs-number">120</span>] ) <span class="hljs-comment"># 将连续变量划分为离散区间</span><br>df.pivot_table(<span class="hljs-string">&#x27;是否生还&#x27;</span>, index= [<span class="hljs-string">&#x27;性别&#x27;</span>, age], columns=<span class="hljs-string">&#x27;船舱等级&#x27;</span>)<br>df.pivot_table(<span class="hljs-string">&#x27;是否生还&#x27;</span>, index= <span class="hljs-string">&#x27;性别&#x27;</span>, columns=[<span class="hljs-string">&#x27;船舱等级&#x27;</span>,age]) <span class="hljs-comment"># 行列不影响</span><br><span class="hljs-comment"># 四个特征：性别、船舱等级、年龄、费用</span><br>fare = pd.qcut( df[<span class="hljs-string">&#x27;费用&#x27;</span>], <span class="hljs-number">2</span> ) <span class="hljs-comment"># 将费用自动划分为两部分</span><br>df.pivot_table(<span class="hljs-string">&#x27;是否生还&#x27;</span>, index= [<span class="hljs-string">&#x27;船舱等级&#x27;</span>,fare], columns=[<span class="hljs-string">&#x27;性别&#x27;</span>, age])<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403291149206.png"></p><p>一个特征：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403291150743.png"></p><p>两个特征：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403291150429.png"></p><p>三个特征：</p><p><img src="C:/Users/sun%27jia%27xin/AppData/Roaming/Typora/typora-user-images/image-20240329115103503.png"></p><p>四个特征：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403291152988.png"></p><p>在上述示例中，数据透视表中的数值默认是输出特征“是否生还”的均值 （mean），行标签和列标签变成了其它的输入特征。值得注意的是，pivot_table() 方法有一个很重要的参数：aggfunc，其默认值 是’mean’，除此以外，所有的聚合函数 ‘max’、’min’、’sum’、’count’ 均可使用。 显然，对于这里的“是否生还，来说的话，’mean’就是最好的选择，其刚好为概率。</p>]]></content>
    
    
    <categories>
      
      <category>Pandas</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyTorch基础</title>
    <link href="/2024/03/27/%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <url>/2024/03/27/%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E4%B8%8E%E9%A2%84%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一、数据操作"><a href="#一、数据操作" class="headerlink" title="一、数据操作"></a>一、数据操作</h1><p>PyTorch的数据操作基本与NumPy相同：</p><p>在PyTorch里面用的是torch，创建数组用的是torch.tensor()</p><p>在NumPy里面用的是np，创建数组用的是np.array()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br>x=torch.arange(<span class="hljs-number">12</span>) <span class="hljs-comment"># 生成数组</span><br><span class="hljs-built_in">print</span>(x.shape) <span class="hljs-comment"># 张量总数</span><br><span class="hljs-built_in">print</span>(x.numel()) <span class="hljs-comment"># 数量</span><br>x.reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>) <span class="hljs-comment"># 改变张量形状</span><br>torch.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)) <span class="hljs-comment"># 0数组(2个3行4列)</span><br>torch.ones((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)) <span class="hljs-comment"># 1数组</span><br>torch.randn(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment"># 随机数组</span><br><br>torch.tensor([[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]])<span class="hljs-comment">#为张量赋值</span><br>x = torch.tensor([<span class="hljs-number">1.0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>])<br>y = torch.tensor([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>])<br>x + y, x - y, x * y, x / y, x ** y <span class="hljs-comment"># 张量运算</span><br>torch.exp(x) <span class="hljs-comment">#  指数运算</span><br><br>x=torch.tensor(<span class="hljs-number">12</span>,dtype=torch.float32.reshape((<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)))<br>y=torch.tensor([[<span class="hljs-number">2.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]])<br>torch.cat((x,y),dim=<span class="hljs-number">0</span>) <span class="hljs-comment"># 按行合并（6行）</span><br>torch.cat((x,y),dim=<span class="hljs-number">1</span>) <span class="hljs-comment"># 按列合并（8列）</span><br>x.<span class="hljs-built_in">sum</span>() <span class="hljs-comment"># 求和</span><br><br><span class="hljs-comment">#广播机制</span><br>x=torch.arange(<span class="hljs-number">3</span>).reshape((<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br>y=torch.arange(<span class="hljs-number">2</span>).reshape((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br>x+y <span class="hljs-comment"># 输出为3*2的张量</span><br><br>x[-<span class="hljs-number">1</span>],x[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>] <span class="hljs-comment"># 取值</span><br>x[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]=<span class="hljs-number">9</span> <span class="hljs-comment"># 赋值</span><br>x[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>,:]=<span class="hljs-number">10</span> <span class="hljs-comment"># 区域赋值(所有的列)</span><br><br><span class="hljs-comment">#重新分配内存</span><br>before=<span class="hljs-built_in">id</span>(y)<br>y=y+x<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(y))<br><span class="hljs-comment">#原地操作(内存没发生变化)</span><br>before=<span class="hljs-built_in">id</span>(x)<br>x+=y<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(x))<br><br>a=x.numpy()<br>b=torch.tensor(a) <span class="hljs-comment"># 转换为numpy数组</span><br>a = torch.tensor([<span class="hljs-number">3.5</span>])<br>a, a.item(), <span class="hljs-built_in">float</span>(a), <span class="hljs-built_in">int</span>(a) <span class="hljs-comment"># 转为numpy标量，浮点，整数型</span><br></code></pre></td></tr></table></figure><h1 id="二、数据预处理"><a href="#二、数据预处理" class="headerlink" title="二、数据预处理"></a>二、数据预处理</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-comment">#创建人工数据</span><br>os.makedirs(os.path.join(<span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>), exist_ok=<span class="hljs-literal">True</span>)<br>data_file = os.path.join(<span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;house_tiny.csv&#x27;</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(data_file, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">&#x27;NumRooms,Alley,Price\n&#x27;</span>)<br>    f.write(<span class="hljs-string">&#x27;NA,Pave,127500\n&#x27;</span>)<br>    f.write(<span class="hljs-string">&#x27;2,NA,106000\n&#x27;</span>)<br>    f.write(<span class="hljs-string">&#x27;4,NA,178100\n&#x27;</span>)<br>    f.write(<span class="hljs-string">&#x27;NA,NA,140000\n&#x27;</span>)<br><span class="hljs-comment">#读取文件</span><br>data=pd.read_csv(data_file)<br><span class="hljs-built_in">print</span>(data)<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403261139240.png"></p><h2 id="1-插值与删除"><a href="#1-插值与删除" class="headerlink" title="1. 插值与删除"></a>1. 插值与删除</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 插值与删除</span><br><span class="hljs-comment"># 数值字段缺失值的插入</span><br>inputs,outputs = data.iloc[:,<span class="hljs-number">0</span>:<span class="hljs-number">2</span>],data.iloc[:,<span class="hljs-number">2</span>] <span class="hljs-comment"># 提取列</span><br>inputs = inputs.fillna(inputs.mean()) <span class="hljs-comment"># 给列为数值字段的NaN缺失值填充为列的平均值</span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403261201101.png"></p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403261200706.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 字符串缺失值的插入</span><br>inputs = pd.get_dummies(inputs,dummy_na=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 实际则为将非数值字段的每类扩展为不同的列，赋值为0和1，也就是将为nan的拿出来当作单独一列</span><br><span class="hljs-built_in">print</span>(inputs)<br>x,y = torch.tensor(inputs.values),torch.tensor(outputs.values) <span class="hljs-comment"># 转换为张量</span><br><span class="hljs-built_in">print</span>(x,y)<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403261205985.png"></p><h2 id="2-范数"><a href="#2-范数" class="headerlink" title="2. 范数"></a>2. 范数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">u = torch.tensor([<span class="hljs-number">3.0</span>,-<span class="hljs-number">4.0</span>])<br>torch.norm(u) <span class="hljs-comment"># 二范数</span><br>torch.<span class="hljs-built_in">abs</span>(u).<span class="hljs-built_in">sum</span>() <span class="hljs-comment"># 一范数</span><br>torch.norm(torch.ones(<span class="hljs-number">4</span>,<span class="hljs-number">9</span>)) <span class="hljs-comment"># 矩阵的F范数</span><br></code></pre></td></tr></table></figure><h2 id="3-按轴求和"><a href="#3-按轴求和" class="headerlink" title="3. 按轴求和"></a>3. 按轴求和</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = torch.ones((<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>))<br>a.shape<br>a.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>).shape <span class="hljs-comment"># 对第二个轴求和，维度会下降</span><br>a.<span class="hljs-built_in">sum</span>(axis=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]).shape <span class="hljs-comment"># 对第一和第二个轴求和，维度会下降</span><br>a.<span class="hljs-built_in">sum</span>(axis=[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],keepdim=<span class="hljs-literal">True</span>).shape <span class="hljs-comment"># 对第一和第三个轴求和，维度不会下降</span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403261222405.png"></p><h1 id="三、自动求导"><a href="#三、自动求导" class="headerlink" title="三、自动求导"></a>三、自动求导</h1><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h2><p>正向传播：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403272107026.png"></p><p>反向传播：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403272113293.png"></p><p>自动求导的两种形式</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403272112074.png"></p><p>也就是正向从x出发，反向从y出发。反向传递直接拿正向的结果来用，正向传播的所有结果需要存储起来。</p><p><strong>理解：正向传播是求函数值和导数，反向传播是根据函数值反向计算参数的偏导数，举个例子y&#x3D;w1x1+w2x2,正向就是输入x1,x2，求出y,还有y和x1,x2的导数。反向就是根据算出的y（公式算出的预测值）和实际值，比如树高y，实际值为5米，根据x1,x2算出来是3米，这就是损失函数误差，反向传播就是对w1,w2进行求偏导，不停的循环，得出误差最小（最优的值）。</strong></p><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h2><ul><li><h3 id="自动求导"><a href="#自动求导" class="headerlink" title="自动求导"></a>自动求导</h3></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.arange(<span class="hljs-number">4.0</span>)<br>x.requires_grad_(<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 代表需要梯度，等价于tensor([0., 1., 2., 3.],                                                               requires_grad=True)</span><br>x.grad  <span class="hljs-comment"># 用于存储并查看y关于x的梯度，默认为None</span><br>y = <span class="hljs-number">2</span> * torch.dot(x, x) <span class="hljs-comment"># 此时为一个标量</span><br>y.backward()  <span class="hljs-comment"># 反向传播函数来自动计算y关于x每个分量的梯度</span><br>x.grad  <span class="hljs-comment"># 查看梯度</span><br>x.grad == <span class="hljs-number">4</span> * x  <span class="hljs-comment"># 验证</span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403272142614.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在默认情况下，pytorch会累计梯度，我们需要清除之前的值</span><br>x.grad.zero_()  <span class="hljs-comment"># 清除之前的梯度,不清除的话，梯度会累加</span><br>y = x.<span class="hljs-built_in">sum</span>() <span class="hljs-comment"># 相当于是y=x+x+x+x,求导后均为1</span><br>y.backward()<br>x.grad<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403272157509.png"></p><ul><li><h3 id="y为标量"><a href="#y为标量" class="headerlink" title="y为标量"></a>y为标量</h3></li></ul><p> <strong>注意：目的不是计算微分矩阵，而是批量中每个样本单独计算的偏导数之和</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">x.grad.zero_()<br>y = x * x<br>y.<span class="hljs-built_in">sum</span>().backward()  <span class="hljs-comment"># 将y转换为标量，等价于y.backward(torch.ones(len(x))</span><br>x.grad<br></code></pre></td></tr></table></figure><p><strong>这里y是向量，x是向量，倘若y对x求导，那么求导后是矩阵，我们不需要矩阵，因为loss一般是标量，所以我们需要先把y变为标量。实则为先得到 y&#x3D;x1^2^+x2^2^+x3^2^+x4^2^, 然后再分别对其求导。</strong></p><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403272159898.png"></p><ul><li><h3 id="函数脱离计算图"><a href="#函数脱离计算图" class="headerlink" title="函数脱离计算图"></a>函数脱离计算图</h3></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">x.grad.zero_()<br>y = x * x<br>u = y.detach()  <span class="hljs-comment"># 令y脱离计算图以外，作为一个常数，值为x*x</span><br>z = u * x<br>z.<span class="hljs-built_in">sum</span>().backward()  <span class="hljs-comment"># 这样求导后得到的即为z</span><br>x.grad<br>x.grad == u  <span class="hljs-comment"># 验证</span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403272158223.png"></p><ul><li><h3 id="控制流-函数、条件、循环等"><a href="#控制流-函数、条件、循环等" class="headerlink" title="控制流(函数、条件、循环等)"></a>控制流(函数、条件、循环等)</h3></li></ul><p>函数结果为f(a)&#x3D;c，c有两种结果，一种为c&#x3D;b&#x3D;a2^n^&#x3D;Ca(C表示常数)，另一种为c&#x3D;100<em>b&#x3D;100</em>a2^n^&#x3D;Ca(C表示常数，最后函数是f(a)&#x3D;Ca，求导结果都是f(a)&#x2F;a</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">a</span>):<br>    b = a * <span class="hljs-number">2</span><br>    <span class="hljs-keyword">while</span> b.norm() &lt; <span class="hljs-number">1000</span>:<br>        b = b * <span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> b.<span class="hljs-built_in">sum</span>() &gt; <span class="hljs-number">0</span>:<br>        c = b<br>    <span class="hljs-keyword">else</span>:<br>        c = <span class="hljs-number">100</span> * b<br>    <span class="hljs-keyword">return</span> c<br>    <br>a = torch.rand(size=(), requires_grad=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 生成一个随机标量，表示需要梯度</span><br>d = f(a)<br>d.backward()<br>a.grad<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PyTorch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵求导原理</title>
    <link href="/2024/03/26/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/"/>
    <url>/2024/03/26/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<p><strong>声明：以下内容来自知乎up主[lterator](<a href="https://zhuanlan.zhihu.com/p/263777564">矩阵求导的本质与分子布局、分母布局的本质（矩阵求导——本质篇） - 知乎 (zhihu.com)</a>)</strong></p><p>首先，对于函数与变量，分别有三种形式为标量，向量，矩阵。针对不同的类型，求导结果不同。</p><h2 id="一、布局"><a href="#一、布局" class="headerlink" title="一、布局"></a>一、布局</h2><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403261913557.png"></p><p><strong>总的来说，可以概括为：</strong></p><ul><li><strong>谁是列向量就是谁的布局。(是谁的布局谁就是行)</strong></li><li><strong>求导时按列向量求导，按行向量写。</strong></li></ul><p>理解：</p><ul><li><p>第一条是说：</p><p>如果分子为列向量，那么就是分子布局，分母是列向量就是分母布局。</p><p>是分子布局的话，行为分子的行，列为分母的列。分母布局亦是。</p></li><li><p>第二条是说：</p><p>对于(3)式，分子f是二维列向量，x是三维行向量，那么求导的f要按列向量求，也就是说每一列都是二维的，第一个数是f1，第二个数是f2。而写的时候要按行向量写，也就是每一行都是三维的，第一个数是x1，第二个是x2，第三个是x3</p><p>对于(4)式，分子f是二维行向量，x是三维列向量，那么求导的f要按列向量求，也就是说每一列都是三维的，第一个数是x1，第二个是x2，第三个是x3。而写的时候要按行向量写，也就是说每一行都是二维的，第一个数是f1，第二个数是f2。</p></li></ul><p><strong>注意：行和列是人为定义的，用哪个布局没有限制，对于一个向量求导可以用分子布局，也可以用分母布局。假如用分子布局的话，那么结果的第一个维度就用分子的维度就行，不论分子是行还是列向量。</strong></p><h2 id="二、求导"><a href="#二、求导" class="headerlink" title="二、求导"></a>二、求导</h2><h3 id="1-函数为标量，变量为向量"><a href="#1-函数为标量，变量为向量" class="headerlink" title="1. 函数为标量，变量为向量"></a>1. 函数为标量，变量为向量</h3><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403261927298.png"></p><p><strong>注意：梯度向量形式就是列向量偏导形式</strong></p><h3 id="2-函数为标量，变量为矩阵"><a href="#2-函数为标量，变量为矩阵" class="headerlink" title="2. 函数为标量，变量为矩阵"></a>2. 函数为标量，变量为矩阵</h3><p><strong>补充：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403261939070.png"></p><p><strong>求导形式：</strong></p><p>行向量的形式：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403261950829.png"></p><p>梯度向量的形式：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403262025887.png"></p><p>矩阵的形式：</p><p>两种不同布局的矩阵形式</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403262026903.png"></p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403262026369.png"></p><h3 id="3-函数为矩阵，变量为矩阵"><a href="#3-函数为矩阵，变量为矩阵" class="headerlink" title="3. 函数为矩阵，变量为矩阵"></a>3. 函数为矩阵，变量为矩阵</h3><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403262035184.png"></p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403262035698.jpeg"></p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403262034897.png"></p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403262034136.jpeg"></p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403262036600.png"></p><h3 id="5-分子布局的矩阵求导运算"><a href="#5-分子布局的矩阵求导运算" class="headerlink" title="5. 分子布局的矩阵求导运算"></a>5. 分子布局的矩阵求导运算</h3><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403272000499.png"></p>]]></content>
    
    
    <categories>
      
      <category>PyTorch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>感知机</title>
    <link href="/2024/03/24/%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <url>/2024/03/24/%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h1><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403242012186.png"></p><h2 id="二、模型"><a href="#二、模型" class="headerlink" title="二、模型"></a>二、模型</h2><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403242015805.png"></p><h2 id="三、算法"><a href="#三、算法" class="headerlink" title="三、算法"></a>三、算法</h2><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403242016275.png"></p><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><p>这里用鸢尾花数据集</p><h3 id="1-不调包"><a href="#1-不调包" class="headerlink" title="1.  不调包"></a>1.  不调包</h3><p>首先读取数据，画出原来的散点图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 读取数据</span><br>iris = load_iris() <span class="hljs-comment"># 读取鸢尾花数据集 返回一个字典，包括data数据与target特征</span><br>df = pd.DataFrame(iris.data,columns=iris.feature_names) <span class="hljs-comment"># 将data存储，每列对应一个特征，特征名为数据集中的特征名</span><br>df[<span class="hljs-string">&#x27;lable&#x27;</span>] = iris.target <span class="hljs-comment"># 标签存储为label</span><br>df.columns = [<span class="hljs-string">&#x27;sepal length&#x27;</span>, <span class="hljs-string">&#x27;sepal width&#x27;</span>, <span class="hljs-string">&#x27;petal length&#x27;</span>, <span class="hljs-string">&#x27;petal width&#x27;</span>, <span class="hljs-string">&#x27;label&#x27;</span>] <span class="hljs-comment"># 重命名每列</span><br>df.label.value_counts() <span class="hljs-comment"># 计算标签列中每个类别的数量</span><br><br><span class="hljs-comment"># 画散点图</span><br>plt.scatter(df[:<span class="hljs-number">50</span>][<span class="hljs-string">&#x27;sepal length&#x27;</span>],df[:<span class="hljs-number">50</span>][<span class="hljs-string">&#x27;sepal width&#x27;</span>],label=<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-comment"># 绘制前50个数据的散点图，标记为0</span><br>plt.scatter(df[<span class="hljs-number">50</span>:<span class="hljs-number">100</span>][<span class="hljs-string">&#x27;sepal length&#x27;</span>],df[<span class="hljs-number">50</span>:<span class="hljs-number">100</span>][<span class="hljs-string">&#x27;sepal width&#x27;</span>],label=<span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-comment"># 绘制后50个数据的散点图，标记为</span><br>plt.xlabel(<span class="hljs-string">&#x27;sepal length&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;sepal width&#x27;</span>)<br>plt.legend() <span class="hljs-comment"># 增加图例</span><br><br>data = np.array(df.iloc[:<span class="hljs-number">100</span>,[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>]]) <span class="hljs-comment"># 取出数据集的前两列和最后一列标签列组成numpy数组</span><br>x,y = data[:,:-<span class="hljs-number">1</span>], data[:,-<span class="hljs-number">1</span>] <span class="hljs-comment"># 前两列赋值给X 最后一列赋值给y</span><br>y = np.array([<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> y] ) <span class="hljs-comment"># 将标签为0的赋值为-1，标签为1的赋值为0</span><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403251916065.png"></p><p>之后写模型的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>): <span class="hljs-comment"># 初始化</span><br>        self.w = np.ones(<span class="hljs-built_in">len</span>(data[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>,dtype=np.float32) <span class="hljs-comment"># data的列的长度-1为w的维度，因为数据是二维的，w也是二维的</span><br>        self.b = <span class="hljs-number">0</span> <span class="hljs-comment"># 偏置</span><br>        self.l_rate = <span class="hljs-number">0.1</span> <span class="hljs-comment"># 学习率</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sign</span>(<span class="hljs-params">self,w,x,b</span>): <span class="hljs-comment"># 感知机的激活函数</span><br>        y = np.dot(w,x) + b<br>        <span class="hljs-keyword">return</span> y<br><br><span class="hljs-comment"># while True 表示将会一直循环下去，首先计数误分类点为0，进入for循环，遍历每个x与y进行更新权重，每次更新权重就将</span><br>    <span class="hljs-comment"># 误分类点数加一，若一次遍历后误分类点数不为0的话，将误分类计数设为0再进入下一次遍历，直到遍历一次x与y（也就是100次）</span><br>    <span class="hljs-comment"># 后误分类计数为0，也就是没有误分类点了，终止while循环。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fit</span>(<span class="hljs-params">self,x_train,y_train</span>): <span class="hljs-comment"># 梯度下降算法</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            wrong_count = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x_train)):<br>                x = x_train[i]<br>                y = y_train[i]<br>                <span class="hljs-keyword">if</span> y * self.sign(self.w,x,self.b) &lt;= <span class="hljs-number">0</span>:<br>                    self.w = self.w + self.l_rate * np.dot(y,x)<br>                    self.b = self.b + self.l_rate * y<br>                    wrong_count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> wrong_count == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Perceptron Model&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self</span>): <span class="hljs-comment"># 评估性能，这里pass</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>最后调用函数，画出超平面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 调用函数</span><br>perceptron = Model()<br>perceptron.fit(x,y)<br><br><span class="hljs-comment"># 画出超平面</span><br>x_points = np.linspace(<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>) <span class="hljs-comment"># 生成4到7的等间隔的包含10个点的数组，作为横坐标</span><br><span class="hljs-comment"># 超平面的公式为 w1*x1 + w2*x2 + b是一条直线，所以这里是将横坐标代入到超平面中，求出对应的纵坐标，作为y轴</span><br>y_points = -(perceptron.w[<span class="hljs-number">0</span>] * x_points + perceptron.b) / perceptron.w[<span class="hljs-number">1</span>]<br>plt.plot(x_points, y_points) <span class="hljs-comment"># 画出横纵坐标以及超平面</span><br><br>plt.plot(data[:<span class="hljs-number">50</span>,<span class="hljs-number">0</span>],data[:<span class="hljs-number">50</span>,<span class="hljs-number">1</span>],<span class="hljs-string">&#x27;bo&#x27;</span>,color = <span class="hljs-string">&#x27;blue&#x27;</span>,label = <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-comment"># 前50个数据</span><br>plt.plot(data[<span class="hljs-number">50</span>:<span class="hljs-number">100</span>,<span class="hljs-number">0</span>],data[<span class="hljs-number">50</span>:<span class="hljs-number">100</span>,<span class="hljs-number">1</span>],<span class="hljs-string">&#x27;bo&#x27;</span>,color = <span class="hljs-string">&#x27;orange&#x27;</span>,label = <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-comment"># 后50个数据</span><br>plt.xlabel(<span class="hljs-string">&#x27;sepal length&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;sepal width&#x27;</span>)<br>plt.legend() <span class="hljs-comment"># 图例</span><br><br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403251921460.png"></p><h3 id="2-调包"><a href="#2-调包" class="headerlink" title="2. 调包"></a>2. 调包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sklearn<br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Perceptron<br><br>clf = Perceptron(fit_intercept=<span class="hljs-literal">True</span>,<br>                 tol=<span class="hljs-literal">None</span>,<br>                 max_iter=<span class="hljs-number">1000</span>,<br>                 shuffle=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># fit_intercept=True: 控制是否应该在模型中包含偏置项。如果设置为 True，则模型会自动添加一个偏置项（常数项），默认为 True。</span><br><span class="hljs-comment"># max_iter=1000: 控制随机梯度下降法的最大迭代次数。这个参数指定了在训练期间要执行的最大迭代次数，默认为 1000。</span><br><span class="hljs-comment"># shuffle=True: 控制每次迭代时是否要打乱训练数据。如果设置为 True，则在每次迭代之前会对训练数据进行洗牌（随机排列），以避免模型陷入某些数据的顺序导致的困境，默认为 True</span><br><span class="hljs-comment"># tol 参数规定了如果本次迭代的损失和上次迭代的损失之差小于一个特定值时，停止迭代。所以我们需要设置 tol=None 使之可以继续迭代：</span><br>clf.fit(x,y) <span class="hljs-comment"># 训练</span><br><span class="hljs-built_in">print</span>(clf.coef_) <span class="hljs-comment"># 输出权重（注意是个矩阵，是二维的）</span><br><span class="hljs-built_in">print</span>(clf.intercept_) <span class="hljs-comment"># 输出截距</span><br><br><span class="hljs-comment"># 画布大小</span><br>plt.figure(figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>))<br><span class="hljs-comment"># 中文标题</span><br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>]=[<span class="hljs-string">&#x27;SimHei&#x27;</span>]<br>plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span><br>plt.title(<span class="hljs-string">&#x27;鸢尾花线性数据示例&#x27;</span>)<br>plt.scatter(data[:<span class="hljs-number">50</span>, <span class="hljs-number">0</span>], data[:<span class="hljs-number">50</span>, <span class="hljs-number">1</span>], c=<span class="hljs-string">&#x27;b&#x27;</span>, label=<span class="hljs-string">&#x27;Iris-setosa&#x27;</span>,)<br>plt.scatter(data[<span class="hljs-number">50</span>:<span class="hljs-number">100</span>, <span class="hljs-number">0</span>], data[<span class="hljs-number">50</span>:<span class="hljs-number">100</span>, <span class="hljs-number">1</span>], c=<span class="hljs-string">&#x27;orange&#x27;</span>, label=<span class="hljs-string">&#x27;Iris-versicolor&#x27;</span>)<br><span class="hljs-comment"># 画感知机的线</span><br>x_ponits = np.arange(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>)<br>y_ = -(clf.coef_[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]*x_ponits + clf.intercept_)/clf.coef_[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>plt.plot(x_ponits, y_)<br>plt.legend()  <span class="hljs-comment"># 显示图例</span><br>plt.grid(<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 不显示网格</span><br>plt.xlabel(<span class="hljs-string">&#x27;sepal length&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;sepal width&#x27;</span>)<br>plt.legend()<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/202403251922345.png"></p>]]></content>
    
    
    <categories>
      
      <category>统计机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>统计机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础课</title>
    <link href="/2024/03/22/Python%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
    <url>/2024/03/22/Python%E5%9F%BA%E7%A1%80%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<p><strong>声明：以下代码与图片来自山西大学复杂系统研究所的祁宏教授</strong></p><h3 id="一-数据类型"><a href="#一-数据类型" class="headerlink" title="一. 数据类型"></a>一. 数据类型</h3><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="数据类型"></p><h3 id="二-关键字"><a href="#二-关键字" class="headerlink" title="二. 关键字"></a>二. 关键字</h3><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/image-20240321203145867.png" alt="关键字"></p><h3 id="三-运算符"><a href="#三-运算符" class="headerlink" title="三. 运算符"></a>三. 运算符</h3><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/image-20240321203858558.png" alt="运算符"></p><h3 id="四-循环"><a href="#四-循环" class="headerlink" title="四. 循环"></a>四. 循环</h3><h4 id="1-while循环"><a href="#1-while循环" class="headerlink" title="1. while循环"></a>1. while循环</h4><p><strong>注意：while循环的i需要定义</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">i = <span class="hljs-number">0</span>  <span class="hljs-comment"># while中的i需要定义</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    i = <span class="hljs-built_in">input</span>()<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;q&#x27;</span>:<br>    <span class="hljs-comment"># break(输入q直接跳出循环)——直接跳出while语句</span><br>    <span class="hljs-comment"># continue(输入q本次不进行循坏，直到下次输入别的字母又进行循坏)——不执行while语句后的所有语句</span><br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-comment"># Ture代表非0的数或者非空列表</span><br><br><span class="hljs-keyword">while</span> i != <span class="hljs-string">&#x27;q&#x27;</span>:<br>    i = <span class="hljs-built_in">input</span>()<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;q&#x27;</span>:<br>    <span class="hljs-comment"># break(输入q直接跳出循环)</span><br>    <span class="hljs-comment"># continue(输入q本次不进行循坏，直到下次输入别的字母又进行循坏)</span><br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><h4 id="2-for循环"><a href="#2-for循环" class="headerlink" title="2. for循环"></a>2. for循环</h4><p><strong>注意：for循环的i不需要定义</strong></p><h3 id="五-列表"><a href="#五-列表" class="headerlink" title="五. 列表"></a>五. 列表</h3><h4 id="1-列表里的函数与方法"><a href="#1-列表里的函数与方法" class="headerlink" title="1. 列表里的函数与方法"></a>1. 列表里的函数与方法</h4><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/image-20240321203946907.png" alt="列表方法"></p><ul><li><h5 id="有关list中函数与方法的甄别-sort-reverse与sorted-reversed"><a href="#有关list中函数与方法的甄别-sort-reverse与sorted-reversed" class="headerlink" title="有关list中函数与方法的甄别(sort,reverse与sorted,reversed)"></a>有关list中函数与方法的甄别(sort,reverse与sorted,reversed)</h5></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># list函数(函数会创造出新的变量)</span><br>l = [<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br>l2 = <span class="hljs-built_in">reversed</span>(l)  <span class="hljs-comment"># 将l改变为一个新的l2(对其反转)</span><br>l3 = <span class="hljs-built_in">sorted</span>(l)  <span class="hljs-comment"># 将l改变为新的l3(对其排序)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(l2)) \ <span class="hljs-built_in">print</span>(l3) <span class="hljs-comment"># 注意：这里想输出l2需要将其转换为list</span><br><br><span class="hljs-comment"># list方法(方法不会创造出新的变量)</span><br>l4 = l.reverse()  <span class="hljs-comment"># 将l本身改变了，不会赋值给l4</span><br>l5 = l.sort()  <span class="hljs-comment"># 将l本身改变了，不会赋值给l5</span><br><span class="hljs-built_in">print</span>(l, l4)  <span class="hljs-comment"># 不输出l4，输出l本身，改变了l本身</span><br><span class="hljs-built_in">print</span>(l, l5)  <span class="hljs-comment"># 不输出l5，输出l本身，改变了l本身</span><br></code></pre></td></tr></table></figure><p>​结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(l, <span class="hljs-built_in">list</span>(l2))<br>[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>] [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(l, l3)<br>[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>] [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br><span class="hljs-built_in">print</span>(l, l4)  <br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <span class="hljs-literal">None</span><br><span class="hljs-built_in">print</span>(l, l5)  <br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p><strong>注意：当出现  <code>&lt;list_reverseiterator object at 0x00000227BAB3D2B0&gt;</code>  时意味着要转换为列表才能输出</strong></p><ul><li><h5 id="list常用方法"><a href="#list常用方法" class="headerlink" title="list常用方法"></a>list常用方法</h5></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># list方法</span><br><span class="hljs-comment"># 插入元素 self.append()  self.insert()  self.extend()</span><br>l.append(<span class="hljs-number">4</span>)  <span class="hljs-comment"># 在末尾插入元素4</span><br>l.append([<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]) <span class="hljs-comment"># 在末尾插入列表[4,5](也就是在列表中插入列表)</span><br>l.extend([<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])  <span class="hljs-comment"># 在末尾插入元素4和5(在列表中插入多个元素加[])</span><br>l.insert(<span class="hljs-number">2</span>, <span class="hljs-number">2.5</span>)  <span class="hljs-comment"># 在2号位置后插入2.5</span><br>l.insert(<span class="hljs-number">10</span>, <span class="hljs-number">4.5</span>)  <span class="hljs-comment"># 超出范围直接加在末尾</span><br>s = <span class="hljs-string">&quot;Hello&quot;</span><br>l.extend(s) <span class="hljs-comment"># 将字符串拆分为一个一个的插入末尾</span><br>l.extend([s]) <span class="hljs-comment"># 直接将Hello插入末尾(要加[])</span><br><br><span class="hljs-comment"># 删除元素 self.pop()  self.index()  self.remove()  self.clear()</span><br><span class="hljs-string">&#x27;&#x27;&#x27;pop和index针对索引，remove针对元素，clear针对列表&#x27;&#x27;&#x27;</span><br>l = [<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">5</span>，<span class="hljs-number">7</span>]<br>l.pop() <span class="hljs-comment"># 删除末尾最后一个元素</span><br>l.pop(<span class="hljs-number">2</span>) <span class="hljs-comment"># 删除并返回索引为2的元素</span><br>l.index(<span class="hljs-number">2</span>) <span class="hljs-comment"># 返回列表中第一个值为2的索引</span><br>l.remove(<span class="hljs-number">2</span>) <span class="hljs-comment"># 删除元素为2的元素</span><br>l.clear() <span class="hljs-comment"># 全部删除</span><br></code></pre></td></tr></table></figure><p>​删除元素方法的结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">l</span> =<span class="hljs-meta"> [1，2，5，7]</span><br><span class="hljs-attribute">l</span>.pop()—— 输出为<span class="hljs-number">7</span>,l为[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br><span class="hljs-attribute">l</span>.pop(<span class="hljs-number">2</span>)—— 输出为<span class="hljs-number">7</span>,l为[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br><span class="hljs-attribute">l</span>.index(<span class="hljs-number">2</span>)—— 输出为<span class="hljs-number">5</span>,l不变<br><span class="hljs-attribute">l</span>.remove(<span class="hljs-number">2</span>)—— 不输出,l为[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>]<br><span class="hljs-attribute">l</span>.clear()—— 不输出,l为[]<br></code></pre></td></tr></table></figure><h4 id="2-列表推导式"><a href="#2-列表推导式" class="headerlink" title="2. 列表推导式"></a>2. 列表推导式</h4><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/image-20240321204037715.png" alt="列表推导式"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 列表推导式</span><br><span class="hljs-comment"># [表达式 for 变量 in 列表 if 筛选变量条件]</span><br>lst = [i * <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>) <span class="hljs-keyword">if</span> i // <span class="hljs-number">2</span> != <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h3 id="六-元组"><a href="#六-元组" class="headerlink" title="六. 元组"></a>六. 元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 元组（元组不可变，但元组其中的列表和字典可以变）</span><br>my_tuple = ([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;)<br>my_tuple[<span class="hljs-number">0</span>].append(<span class="hljs-number">4</span>)  <span class="hljs-comment"># 修改元组里的列表（第0号元素为列表，修改列表）</span><br>my_tuple[<span class="hljs-number">1</span>][<span class="hljs-string">&#x27;b&#x27;</span>] = <span class="hljs-number">3</span>  <span class="hljs-comment"># 修改元组里的字典（第1号元素为字典，修改字典里键对应的值）</span><br></code></pre></td></tr></table></figure><h3 id="七-字典"><a href="#七-字典" class="headerlink" title="七. 字典"></a>七. 字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">d = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(keys, value))  <span class="hljs-comment"># zip将他们拉在一起</span><br></code></pre></td></tr></table></figure><h3 id="八-函数"><a href="#八-函数" class="headerlink" title="八. 函数"></a>八. 函数</h3><h4 id="1-函数参数类型"><a href="#1-函数参数类型" class="headerlink" title="1. 函数参数类型"></a>1. 函数参数类型</h4><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/image-20240321204135967.png" alt="参数类型"></p><p>注意：顺序不可更换，要想更换需要在中间加 * </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 位置参数,默认参数,可变长度的位置参数,显式命名的关键字参数,可变长度的关键字参数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">final_score, bass_score=<span class="hljs-number">10</span>, *args, multipliter, **kwargs</span>):<br>    extra_score = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> correct_score <span class="hljs-keyword">in</span> args:<br>        extra_score += correct_score<br>    <span class="hljs-keyword">for</span> wrong_score <span class="hljs-keyword">in</span> kwargs.values():<br>        extra_score -= wrong_score<br>    total_score = final_score + bass_score + multipliter * extra_score<br>    <span class="hljs-keyword">return</span> total_score<br><br>result = score(<span class="hljs-number">60</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, multipliter=<span class="hljs-number">2</span>, wrong1=<span class="hljs-number">1</span>, wrong2=<span class="hljs-number">2</span>) <span class="hljs-comment"># 关键字必须要写参数</span><br>   <span class="hljs-comment"># 位置参数不需要写参数</span><br>                                                                   <span class="hljs-comment"># 默认参数可以进行修改</span><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><h4 id="2-函数用法"><a href="#2-函数用法" class="headerlink" title="2. 函数用法"></a>2. 函数用法</h4><ul><li><h5 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h5></li></ul><p>​是可迭代对象，可以给值赋索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">names = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span><br><span class="hljs-keyword">for</span> index, name <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(names, <span class="hljs-number">1</span>): <span class="hljs-comment"># 表示从第一个索引开始</span><br>    <span class="hljs-built_in">print</span>(index, name) <br><span class="hljs-keyword">for</span> index, name <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(names[<span class="hljs-number">1</span>:]): <span class="hljs-comment"># 舍弃第一个数据‘a’，从第二个数据开始赋索引值</span><br>    <span class="hljs-built_in">print</span>(index, name)<br></code></pre></td></tr></table></figure><p>​结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span> a<br><span class="hljs-number">2</span> b<br><span class="hljs-number">3</span> c<br><span class="hljs-number">4</span> d<br><span class="hljs-number">5</span> e<br><br><span class="hljs-number">0</span> b<br><span class="hljs-number">1</span> c<br><span class="hljs-number">2</span> d<br><span class="hljs-number">3</span> e<br></code></pre></td></tr></table></figure><ul><li><h5 id="self-split"><a href="#self-split" class="headerlink" title="self.split"></a>self.split</h5></li></ul><p>​可以将字符串处理成列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">str1 = <span class="hljs-string">&#x27;12 24 36 45&#x27;</span><br><span class="hljs-built_in">print</span>(str1,<span class="hljs-built_in">type</span>(str1)) —— <span class="hljs-comment"># 输出为12 24 36 48 &lt;class &#x27;str&#x27;&gt;</span><br>list1 = str1.split(<span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-comment"># 将空格剪掉转换为列表</span><br><span class="hljs-built_in">print</span>(list1,<span class="hljs-built_in">type</span>(list1)) —— <span class="hljs-comment"># 输出为[&#x27;12&#x27;, &#x27;24&#x27;, &#x27;36&#x27;, &#x27;48&#x27;] &lt;class &#x27;list&#x27;&gt;</span><br><br>str2 = <span class="hljs-string">&#x27;12, 24, 36, 48&#x27;</span><br><span class="hljs-built_in">print</span>(str2,<span class="hljs-built_in">type</span>(str2)) —— <span class="hljs-comment"># 输出为12, 24, 36, 48 &lt;class &#x27;str&#x27;&gt;</span><br>list2 = str2.split(<span class="hljs-string">&#x27;, &#x27;</span>)  <span class="hljs-comment"># 将逗号与空格剪掉转换为列表</span><br><span class="hljs-built_in">print</span>(list2, <span class="hljs-built_in">type</span>(list2)) —— <span class="hljs-comment"># 输出为[&#x27;12&#x27;, &#x27;24&#x27;, &#x27;36&#x27;, &#x27;48&#x27;] &lt;class &#x27;list&#x27;&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-与-的作用"><a href="#3-与-的作用" class="headerlink" title="3. * 与 ** 的作用"></a>3. * 与 ** 的作用</h4><ul><li><h5 id="解包元组"><a href="#解包元组" class="headerlink" title="* 解包元组"></a>* 解包元组</h5></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 解包</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">addition</span>(<span class="hljs-params">num1, num2, num3</span>):<br>    result = num1 + num2 + num3<br>    <span class="hljs-keyword">return</span> result<br><br>params_tuple = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>result = addition(*params_tuple)  <span class="hljs-comment"># 相当于调用了1，2，3这三个数字（数字从元组中解包出来了）</span><br><span class="hljs-built_in">print</span>(*params_tuple) <span class="hljs-comment"># 可以直接打印出来，结果为1，2，3</span><br><span class="hljs-built_in">print</span>(result) —— 结果为<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><ul><li><h5 id="收集多个数"><a href="#收集多个数" class="headerlink" title="* 收集多个数"></a>* 收集多个数</h5></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a,b,*c=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><ul><li><h5 id="可变长度的位置参数-args"><a href="#可变长度的位置参数-args" class="headerlink" title="* 可变长度的位置参数(*args)"></a>* 可变长度的位置参数(*args)</h5></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在函数中作为可变长度的位置参数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">addition</span>(<span class="hljs-params">*args</span>):<br>    total = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> args: <span class="hljs-comment"># 注意这里是args，不是*args</span><br>        total += i<br>    <span class="hljs-keyword">return</span> total<br><br>result = addition(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>) <span class="hljs-comment"># 调用多个数字</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sum&#x27;</span>, result) —— 结果为<span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><ul><li><h5 id="解包字典的键值对"><a href="#解包字典的键值对" class="headerlink" title="** 解包字典的键值对"></a>** 解包字典的键值对</h5></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 以下是错误的示例</span><br>dict_test=&#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>&#125;<br><span class="hljs-built_in">print</span>(**dict_test) <span class="hljs-comment"># 不能直接打印出来，因为缺少关键字参数a,b,c(区别于解包元组)</span><br>dict1,dict2,dict3=**dict_test <span class="hljs-comment"># 不能分别赋值</span><br><br><span class="hljs-comment"># 正确示例(将字典的键值对解包了)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">myfun</span>(<span class="hljs-params">a,b,c</span>):<br><span class="hljs-built_in">print</span>(a,b,c)<br>dict_test=&#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>&#125;    <br>myfun(**dict_test) <span class="hljs-comment"># 将**字典输入后，输出结果为字典对应的值1，2，3</span><br></code></pre></td></tr></table></figure><ul><li><h5 id="收集多个字典扩展为一个字典"><a href="#收集多个字典扩展为一个字典" class="headerlink" title="** 收集多个字典扩展为一个字典"></a>** 收集多个字典扩展为一个字典</h5></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">30</span>&#125;<br>dict2 = &#123;<span class="hljs-string">&quot;country&quot;</span>: <span class="hljs-string">&quot;USA&quot;</span>&#125;<br>dict1 = &#123;**dict1, **dict2&#125; <span class="hljs-comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 30, &#x27;country&#x27;: &#x27;USA&#x27;&#125;</span><br></code></pre></td></tr></table></figure><ul><li><h5 id="可变长度的关键字参数-kwargs"><a href="#可变长度的关键字参数-kwargs" class="headerlink" title="** 可变长度的关键字参数(**kwargs)"></a>** 可变长度的关键字参数(**kwargs)</h5></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person_info</span>(<span class="hljs-params">name, age, **kwargs</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Name: <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Age: <span class="hljs-subst">&#123;age&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Other Info:&quot;</span>)<br>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> kwargs.items():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;key&#125;</span>: <span class="hljs-subst">&#123;value&#125;</span>&quot;</span>)<br><br>person_info(name=<span class="hljs-string">&quot;Alice&quot;</span>, age=<span class="hljs-number">30</span>, country=<span class="hljs-string">&quot;USA&quot;</span>, job=<span class="hljs-string">&quot;Engineer&quot;</span>) <span class="hljs-comment"># 调用了多个关键字参数</span><br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># Name: Alice</span><br><span class="hljs-comment"># Age: 30</span><br><span class="hljs-comment"># Other Info:</span><br><span class="hljs-comment"># country: USA</span><br><span class="hljs-comment"># job: Engineer</span><br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NumPy进阶</title>
    <link href="/2024/03/21/NumPy%E8%BF%9B%E9%98%B6/"/>
    <url>/2024/03/21/NumPy%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="1-self-argsort"><a href="#1-self-argsort" class="headerlink" title="1.  self.argsort()"></a>1.  <code>self.argsort()</code></h3><h5 id="返回值为数组排序后的索引和数据类型"><a href="#返回值为数组排序后的索引和数据类型" class="headerlink" title="返回值为数组排序后的索引和数据类型"></a>返回值为数组排序后的索引和数据类型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.random.rand(<span class="hljs-number">10</span>)<br>arr2 = arr1.argsort()[-<span class="hljs-number">3</span>:][<span class="hljs-number">0</span>] <span class="hljs-comment"># 取排序后的最大的三个值的索引</span><br></code></pre></td></tr></table></figure><h3 id="2-np-random-choice"><a href="#2-np-random-choice" class="headerlink" title="2.   np.random.choice()"></a>2.   <code>np.random.choice()</code></h3><h5 id="创建数组，共有两个参数，第一个参数是范围相当于range-，第二个参数相当于生成的维度"><a href="#创建数组，共有两个参数，第一个参数是范围相当于range-，第二个参数相当于生成的维度" class="headerlink" title="创建数组，共有两个参数，第一个参数是范围相当于range()，第二个参数相当于生成的维度"></a>创建数组，共有两个参数，第一个参数是范围相当于range()，第二个参数相当于生成的维度</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">np.random.choice(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>) <span class="hljs-comment"># 0~4随机取三个数组成向量</span><br>np.random.choice(<span class="hljs-number">5</span>,(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment"># 0~4随机取6个数组成2行3列的矩阵</span><br>np.random.choice([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment"># 从数组中随机取数组成矩阵</span><br></code></pre></td></tr></table></figure><h3 id="3-np-random-shuffle-np-random-permutation"><a href="#3-np-random-shuffle-np-random-permutation" class="headerlink" title="3.  np.random.shuffle()  np.random.permutation()"></a>3.  <code>np.random.shuffle()</code>  <code>np.random.permutation()</code></h3><h5 id="均为对数组进行随机排列的函数"><a href="#均为对数组进行随机排列的函数" class="headerlink" title="均为对数组进行随机排列的函数"></a>均为对数组进行随机排列的函数</h5><ul><li>第一个函数为修改原数组的排列，结果不能赋值给一个变量</li><li>第二个函数为创造一个随机排列的数组，结果可以赋值给一个变量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.arrange(<span class="hljs-number">10</span>)<br>np.random.shuffle(arr1) <span class="hljs-comment">#对arr1中的数据进行重新排列(对于二维数组用reshape转换)</span><br>np.random.permutation(<span class="hljs-number">10</span>) <span class="hljs-comment"># 直接产生一个新的随机排列的数组(对于二维数组用reshape转换)</span><br></code></pre></td></tr></table></figure><h3 id="4-np-unique"><a href="#4-np-unique" class="headerlink" title="4.  np.unique()"></a>4.  <code>np.unique()</code></h3><h5 id="去除数组里面重复的数"><a href="#去除数组里面重复的数" class="headerlink" title="去除数组里面重复的数"></a>去除数组里面重复的数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>np.unique(arr1) <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>NumPy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NumPy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NumPy基础</title>
    <link href="/2024/03/21/NumPy%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/03/21/NumPy%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="1-数组的创建、类型转换、维度转换"><a href="#1-数组的创建、类型转换、维度转换" class="headerlink" title="1.数组的创建、类型转换、维度转换"></a>1.数组的创建、类型转换、维度转换</h3><h4 id="数组创建np-arrray-np-arrange-np-random"><a href="#数组创建np-arrray-np-arrange-np-random" class="headerlink" title="数组创建np.arrray()np.arrange()np.random."></a>数组创建<code>np.arrray()</code><code>np.arrange()</code><code>np.random.</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment"># np.array()</span><br>arr1 = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]) <span class="hljs-comment"># 创建整型一维数组</span><br>arr2 = np.array([<span class="hljs-number">1.0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]) <span class="hljs-comment"># 创建浮点一维数组</span><br>arr3 = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]) <span class="hljs-comment"># 创建二维数组行矩阵</span><br>arr4 = np.array([[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>]]) <span class="hljs-comment"># 创建二维数组列矩阵</span><br><span class="hljs-comment"># np.arange()</span><br>arr4 = np.arange(<span class="hljs-number">10</span>) <span class="hljs-comment"># 创建1~10的一维递增数组</span><br>arr5 = np.arange(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-comment"># 递增数组(步长为2)</span><br><span class="hljs-comment"># np.ones()、np.zeros()</span><br>np.ones(<span class="hljs-number">3</span>) np.ones((<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment"># 全为1的</span><br>np.zeros(<span class="hljs-number">3</span>) np.zeros((<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment"># 全为0的</span><br><span class="hljs-number">3.14</span>*np.ones((<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)) / np.full((<span class="hljs-number">1</span>,<span class="hljs-number">3</span>),<span class="hljs-number">3.14</span>) <span class="hljs-comment"># 全为3.14的</span><br>np.ones_like(arr1) np.zeros_like(arr1) <span class="hljs-comment"># 填充数字</span><br>np.full_like(arr1,<span class="hljs-number">3.14</span>) <br><br><span class="hljs-comment"># np.random 用于生成随机数组</span><br><span class="hljs-comment"># np.random.rand() # 0~1的均匀分布</span><br>np.random.rand(<span class="hljs-number">10</span>) <span class="hljs-comment"># 随机10个数据的一维数组</span><br>np.random.rand(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>) <span class="hljs-comment"># 随机行为3，列为3的二维数组(一个括号)</span><br><span class="hljs-comment"># np.random.random() # 浮点型</span><br>np.random.random(<span class="hljs-number">10</span>) <span class="hljs-comment"># 一维</span><br>np.random.random((<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment"># 二维(两个括号)</span><br><span class="hljs-comment"># np.random.randint() # 整型</span><br>np.random.randint(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>,(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment">#3行3列的10~100的整型二维数组</span><br><span class="hljs-comment"># np.random.normal() # 正态分布</span><br>np.random.normal(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment"># 3行3列的符合标准正态分布的二维数组</span><br></code></pre></td></tr></table></figure><p><strong>注：之后的代码默认arr1为一维数组，arr2为二维数组。</strong></p><h4 id="数组类型转换self-astype"><a href="#数组类型转换self-astype" class="headerlink" title="数组类型转换self.astype()"></a>数组类型转换<code>self.astype()</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr2 = arr1.astype(<span class="hljs-built_in">float</span>) <span class="hljs-comment"># 整型数组转换为浮点型</span><br>arr1 = arr2.astype(<span class="hljs-built_in">int</span>) <span class="hljs-comment"># 浮点转换为整型</span><br></code></pre></td></tr></table></figure><h4 id="数组维度转换self-reshape"><a href="#数组维度转换self-reshape" class="headerlink" title="数组维度转换self.reshape()"></a>数组维度转换<code>self.reshape</code>()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = arr2.reshape(-<span class="hljs-number">1</span>) <span class="hljs-comment"># 二维数组转换为一维数组(注意：这里的-1代表让python自动计算转换后的维度)</span><br>arr2 = arr1.reshape(<span class="hljs-number">3</span>,-<span class="hljs-number">1</span>) <span class="hljs-comment"># 一维数组转换为二维数组(3行，-1代表自动计算维度)</span><br>arr3 = np.arrange(<span class="hljs-number">10</span>).reshape(<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>) <span class="hljs-comment"># 1~10的随机一维数组转换为了2行5列的二维数组</span><br></code></pre></td></tr></table></figure><h3 id="2-数组的索引访问、修改元素"><a href="#2-数组的索引访问、修改元素" class="headerlink" title="2.数组的索引访问、修改元素"></a>2.数组的索引访问、修改元素</h3><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1[<span class="hljs-number">3</span>] = <span class="hljs-number">5</span> <span class="hljs-comment"># 用索引修改元素——一维</span><br>arr2[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] <span class="hljs-comment"># 用索引访问元素(一个方括号——访问第2行第2列的元素)——二维</span><br></code></pre></td></tr></table></figure><h4 id="花式索引-访问多个元素"><a href="#花式索引-访问多个元素" class="headerlink" title="花式索引 (访问多个元素)"></a>花式索引 (访问多个元素)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1[[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]] <span class="hljs-comment"># 访问第一个和第三个元素——一维</span><br>arr2[[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]] <span class="hljs-comment"># 用索引访问元素(两个方括号——访问2行2列、3行3列的元素)——二维</span><br>                  <span class="hljs-comment"># 第一个[]是行,第二个[]是列</span><br></code></pre></td></tr></table></figure><h3 id="3-矩阵的切片、拷贝"><a href="#3-矩阵的切片、拷贝" class="headerlink" title="3.矩阵的切片、拷贝"></a>3.矩阵的切片、拷贝</h3><h4 id="切片-仅仅是原来数组的视图，不会创建新的变量-self"><a href="#切片-仅仅是原来数组的视图，不会创建新的变量-self" class="headerlink" title="切片 (仅仅是原来数组的视图，不会创建新的变量)   self[]"></a>切片 (仅仅是原来数组的视图，不会创建新的变量)   <code>self[]</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">arr2[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>,<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>] <span class="hljs-comment"># 取第2行到第3行,第2列到随后1列的矩阵</span><br>arr2[<span class="hljs-number">3</span>,:] <span class="hljs-comment"># 取第3行的全部 </span><br>arr2[:,<span class="hljs-number">3</span>] <span class="hljs-comment"># 取第3列的全部(但注意输出为向量而不是列矩阵，目的是为节省空间)</span><br>arr2[:,<span class="hljs-number">3</span>].reshape <span class="hljs-comment"># 提取第3列的全部且输出为列矩阵</span><br><br><span class="hljs-comment"># Numpy仅仅是原来数组的视图，不会创建新的变量</span><br>cut = arr2[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] <span class="hljs-comment"># 切片</span><br>cut[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]=<span class="hljs-number">100</span> <span class="hljs-comment"># 修改其中的元素</span><br><span class="hljs-built_in">print</span>(arr2) <span class="hljs-comment"># 会发现原数组的相应元素也被修改了</span><br></code></pre></td></tr></table></figure><p>​结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">array([[  <span class="hljs-number">6</span>,   <span class="hljs-number">7</span>,   <span class="hljs-number">8</span>,   <span class="hljs-number">9</span>,  <span class="hljs-number">10</span>],<br>       [ <span class="hljs-number">11</span>,  <span class="hljs-number">12</span>, <span class="hljs-number">100</span>,  <span class="hljs-number">14</span>,  <span class="hljs-number">15</span>]])<br></code></pre></td></tr></table></figure><h4 id="拷贝-创建了新的变量-self-copy"><a href="#拷贝-创建了新的变量-self-copy" class="headerlink" title="拷贝 (创建了新的变量)  self[].copy()"></a>拷贝 (创建了新的变量)  <code>self[].copy()</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 拷贝会创建新的变量，不会影响到原视图</span><br>copy = arr2[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>].copy <span class="hljs-comment"># 此时copy是独立的</span><br></code></pre></td></tr></table></figure><h3 id="4-数组的赋值"><a href="#4-数组的赋值" class="headerlink" title="4.数组的赋值"></a>4.数组的赋值</h3><h4 id="赋值-赋值只是绑定，不会创造新的变量"><a href="#赋值-赋值只是绑定，不会创造新的变量" class="headerlink" title="赋值(赋值只是绑定，不会创造新的变量)"></a>赋值(赋值只是绑定，不会创造新的变量)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Numpy的赋值只是绑定，不会创造新的变量</span><br>arr2 = arr1<br>arr2[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span><br><span class="hljs-built_in">print</span>(arr1) <span class="hljs-comment"># 原数组的相应元素也被修改了</span><br><br><span class="hljs-comment"># 复制数组为新的变量，仍然需要self[].copy()方法</span><br>arr2 = arr1.copy <span class="hljs-comment"># 此时arr2为一个新的变量</span><br></code></pre></td></tr></table></figure><h3 id="5-数组的变形"><a href="#5-数组的变形" class="headerlink" title="5.数组的变形"></a>5.数组的变形</h3><h4 id="数组的转置-self-T"><a href="#数组的转置-self-T" class="headerlink" title="数组的转置  self.T"></a>数组的转置  <code>self.T</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># .T只对矩阵有效，因此遇到向量要将其先转换为矩阵</span><br>arr2 = arr1.reshape(<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>)<br>arr3 = arr2.T<br>arr4 = arr2.T <span class="hljs-comment"># 矩阵可以直接进行转置</span><br></code></pre></td></tr></table></figure><h4 id="数组的翻转-np-flipud-np-fliplr"><a href="#数组的翻转-np-flipud-np-fliplr" class="headerlink" title="数组的翻转  np.flipud()  np.fliplr()"></a>数组的翻转  <code>np.flipud()</code>  <code>np.fliplr()</code></h4><p>上下翻转：np.flipud()</p><p>左右翻转：np.fliplr()</p><p><strong>注：在数学上向量是竖着排列的，故而只能使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr3 = np.flipud(arr1) <span class="hljs-comment"># 向量的翻转</span><br>arr4 = np.flipud(arr2) <span class="hljs-comment"># 矩阵上下翻转</span><br>arr5 = np.fliplr(arr2) <span class="hljs-comment"># 矩阵左右翻转</span><br></code></pre></td></tr></table></figure><h4 id="数组的拼接-np-concatenate"><a href="#数组的拼接-np-concatenate" class="headerlink" title="数组的拼接   np.concatenate()"></a>数组的拼接   <code>np.concatenate()</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np.concatenate([arr1,arr3]) <span class="hljs-comment"># 向量的拼接</span><br>np.concatenate([arr2,arr4],axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># 矩阵的按列拼接，默认为axis=0(按行拼接)</span><br></code></pre></td></tr></table></figure><p><strong>注：向量和矩阵不能拼接,除非先将向量转换为矩阵</strong></p><h4 id="数组的分裂-np-split"><a href="#数组的分裂-np-split" class="headerlink" title="数组的分裂  np.split()"></a>数组的分裂  <code>np.split()</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr3,arr4,arr5 = np.split(arr1,[<span class="hljs-number">2</span>,<span class="hljs-number">8</span>]) <span class="hljs-comment"># 向量的分裂，从索引2到索引8截断分裂成3个向量</span><br>arr3,arr4,arr5 = np.split(arr2,[<span class="hljs-number">1</span>，<span class="hljs-number">3</span>]，axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># 按列分裂矩阵，分裂后仍为矩阵</span><br></code></pre></td></tr></table></figure><h3 id="6-数组的广播机制"><a href="#6-数组的广播机制" class="headerlink" title="6.数组的广播机制"></a>6.数组的广播机制</h3><ul><li><p>向量与矩阵之间做运算，向量自动升级为行矩阵</p></li><li><p>行矩阵或列矩阵与矩阵做运算，则其被广播以适配另一个矩阵</p></li></ul><h4 id="向量与行矩阵广播"><a href="#向量与行矩阵广播" class="headerlink" title="向量与行矩阵广播"></a>向量与行矩阵广播</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 向量(1,y)与矩阵(x,y)运算，向量(1,y)被广播成(x,y)</span><br><span class="hljs-comment"># 行矩阵(1,y)与矩阵(x,y)运算，行矩阵(1,y)被广播成(x,y)</span><br>arr1 = np.array([-<span class="hljs-number">100</span>,<span class="hljs-number">0</span>,<span class="hljs-number">100</span>]) / arr1=arr1 = np.array([[-<span class="hljs-number">100</span>,<span class="hljs-number">0</span>,<span class="hljs-number">100</span>]])<br>arr2 = np.random.random((<span class="hljs-number">10</span>,<span class="hljs-number">3</span>))<br><span class="hljs-built_in">print</span>(arr1*arr2)<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1([-<span class="hljs-number">100</span>,    <span class="hljs-number">0</span>,  <span class="hljs-number">100</span>])<br>arr2([[<span class="hljs-number">0.64184236</span>, <span class="hljs-number">0.92884126</span>, <span class="hljs-number">0.62543466</span>],<br>       [<span class="hljs-number">0.38378405</span>, <span class="hljs-number">0.46597221</span>, <span class="hljs-number">0.8844838</span> ],<br>       [<span class="hljs-number">0.05068026</span>, <span class="hljs-number">0.77563276</span>, <span class="hljs-number">0.92239674</span>],<br>       [<span class="hljs-number">0.91164811</span>, <span class="hljs-number">0.37592643</span>, <span class="hljs-number">0.89214386</span>],<br>       [<span class="hljs-number">0.26122901</span>, <span class="hljs-number">0.82832289</span>, <span class="hljs-number">0.30011802</span>],<br>       [<span class="hljs-number">0.50559112</span>, <span class="hljs-number">0.7080077</span> , <span class="hljs-number">0.14343618</span>],<br>       [<span class="hljs-number">0.59117364</span>, <span class="hljs-number">0.91623895</span>, <span class="hljs-number">0.46346609</span>],<br>       [<span class="hljs-number">0.7240537</span> , <span class="hljs-number">0.76051051</span>, <span class="hljs-number">0.37214717</span>],<br>       [<span class="hljs-number">0.8830629</span> , <span class="hljs-number">0.26699637</span>, <span class="hljs-number">0.99830822</span>],<br>       [<span class="hljs-number">0.75797617</span>, <span class="hljs-number">0.24014886</span>, <span class="hljs-number">0.62673243</span>]])<br>arr1*arr2[[-<span class="hljs-number">64.18423647</span>   <span class="hljs-number">0.</span>          <span class="hljs-number">62.54346552</span>]<br>         [-<span class="hljs-number">38.37840458</span>   <span class="hljs-number">0.</span>          <span class="hljs-number">88.44837975</span>]<br>         [ -<span class="hljs-number">5.06802583</span>   <span class="hljs-number">0.</span>          <span class="hljs-number">92.23967399</span>]<br>         [-<span class="hljs-number">91.16481138</span>   <span class="hljs-number">0.</span>          <span class="hljs-number">89.21438585</span>]<br>         [-<span class="hljs-number">26.12290116</span>   <span class="hljs-number">0.</span>          <span class="hljs-number">30.01180228</span>]<br>         [-<span class="hljs-number">50.55911236</span>   <span class="hljs-number">0.</span>          <span class="hljs-number">14.34361837</span>]<br>         [-<span class="hljs-number">59.11736439</span>   <span class="hljs-number">0.</span>          <span class="hljs-number">46.34660855</span>]<br>         [-<span class="hljs-number">72.40537049</span>   <span class="hljs-number">0.</span>          <span class="hljs-number">37.21471661</span>]<br>         [-<span class="hljs-number">88.30629028</span>   <span class="hljs-number">0.</span>          <span class="hljs-number">99.83082246</span>]<br>         [-<span class="hljs-number">75.79761697</span>   <span class="hljs-number">0.</span>          <span class="hljs-number">62.67324251</span>]]<br></code></pre></td></tr></table></figure><h4 id="列矩阵广播"><a href="#列矩阵广播" class="headerlink" title="列矩阵广播"></a>列矩阵广播</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 列矩阵(x,1)与矩阵(x,y)运算，行矩阵(x,1)被广播成(x,y)</span><br>arr1 = np.array([-<span class="hljs-number">100</span>,<span class="hljs-number">0</span>,<span class="hljs-number">100</span>]).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)<br>arr2 = np.random.random((<span class="hljs-number">3</span>,<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(arr1*arr2)<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1([[-<span class="hljs-number">100</span>],<br>       [   <span class="hljs-number">0</span>],<br>       [ <span class="hljs-number">100</span>]])<br>arr2([[<span class="hljs-number">0.9519945</span> , <span class="hljs-number">0.18397963</span>, <span class="hljs-number">0.93968266</span>, <span class="hljs-number">0.17685797</span>, <span class="hljs-number">0.32871508</span>,<br>        <span class="hljs-number">0.67301183</span>, <span class="hljs-number">0.41439795</span>, <span class="hljs-number">0.94014996</span>, <span class="hljs-number">0.030653</span>  , <span class="hljs-number">0.1247722</span> ],<br>       [<span class="hljs-number">0.46747026</span>, <span class="hljs-number">0.07872123</span>, <span class="hljs-number">0.9973935</span> , <span class="hljs-number">0.73324281</span>, <span class="hljs-number">0.52697865</span>,<br>        <span class="hljs-number">0.87598351</span>, <span class="hljs-number">0.78022501</span>, <span class="hljs-number">0.06691926</span>, <span class="hljs-number">0.59863272</span>, <span class="hljs-number">0.24475252</span>],<br>       [<span class="hljs-number">0.32548395</span>, <span class="hljs-number">0.94686565</span>, <span class="hljs-number">0.53828161</span>, <span class="hljs-number">0.76247029</span>, <span class="hljs-number">0.19001698</span>,<br>        <span class="hljs-number">0.70659785</span>, <span class="hljs-number">0.76300795</span>, <span class="hljs-number">0.75767884</span>, <span class="hljs-number">0.94524973</span>, <span class="hljs-number">0.18782533</span>]])<br>arr1*arr2[[-<span class="hljs-number">95.19944981</span> -<span class="hljs-number">18.39796349</span> -<span class="hljs-number">93.96826555</span> -<span class="hljs-number">17.68579675</span> -<span class="hljs-number">32.8715077</span><br>          -<span class="hljs-number">67.30118339</span> -<span class="hljs-number">41.43979544</span> -<span class="hljs-number">94.01499577</span>  -<span class="hljs-number">3.0653003</span>  -<span class="hljs-number">12.47722005</span>]<br>          [  <span class="hljs-number">0.</span>           <span class="hljs-number">0.</span>           <span class="hljs-number">0.</span>           <span class="hljs-number">0.</span>           <span class="hljs-number">0.</span><br>            <span class="hljs-number">0.</span>           <span class="hljs-number">0.</span>           <span class="hljs-number">0.</span>           <span class="hljs-number">0.</span>           <span class="hljs-number">0.</span>        ]<br>          [ <span class="hljs-number">32.54839531</span>  <span class="hljs-number">94.68656469</span>  <span class="hljs-number">53.82816071</span>  <span class="hljs-number">76.2470291</span>   <span class="hljs-number">19.00169753</span><br>           <span class="hljs-number">70.65978472</span>  <span class="hljs-number">76.30079538</span>  <span class="hljs-number">75.76788372</span>  <span class="hljs-number">94.52497266</span>  <span class="hljs-number">18.78253268</span>]]<br></code></pre></td></tr></table></figure><h4 id="行列矩阵同时广播"><a href="#行列矩阵同时广播" class="headerlink" title="行列矩阵同时广播"></a>行列矩阵同时广播</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 行矩阵(1,y)与列矩阵(x,1)运算，都被广播成(x,y)</span><br></code></pre></td></tr></table></figure><p><strong>注：这里所有的乘积可以理解为逐元素相乘，与乘积顺序无关，并不是线性代数中的矩阵乘法</strong></p><p>比如：行矩阵(1,y)与列矩阵(x,1)相乘，不管顺序，都会得到一个3行3列的矩阵</p><h3 id="7-数组的函数"><a href="#7-数组的函数" class="headerlink" title="7.数组的函数"></a>7.数组的函数</h3><h4 id="矩阵乘积函数-np-out-——内积-np-outer——外积"><a href="#矩阵乘积函数-np-out-——内积-np-outer——外积" class="headerlink" title="矩阵乘积函数  np.out()——内积  np.outer——外积"></a>矩阵乘积函数  <code>np.out()</code>——内积  <code>np.outer</code>——外积</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 此为线性代数中的乘积函数</span><br>np.out(arr2,arr3) <span class="hljs-comment"># 矩阵的内积</span><br>np.outer(arr2,arr3) <span class="hljs-comment"># 矩阵的外积</span><br></code></pre></td></tr></table></figure><h4 id="绝对值函数"><a href="#绝对值函数" class="headerlink" title="绝对值函数"></a>绝对值函数</h4><p> <code>np.abs()</code></p><h4 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h4><p><code>np.sin()  np.cos()  np.tan()  </code></p><h4 id="指数函数"><a href="#指数函数" class="headerlink" title="指数函数"></a>指数函数</h4><p><code>np.exp(x)</code>——e的x次方</p><h4 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h4><p><code>np.log(x)</code>——10为底</p><p><code>np.log(x)/np.log(2)</code>——2为底</p><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">np.<span class="hljs-built_in">max</span>(arr,axis=<span class="hljs-number">1</span>)/np.<span class="hljs-built_in">min</span>(arr,axis=<span class="hljs-number">1</span>) <span class="hljs-comment"># 按列寻找最大/小值，输出为每一列的最大值</span><br>np.<span class="hljs-built_in">max</span>(arr) <span class="hljs-comment"># 整体最大值</span><br>np.<span class="hljs-built_in">sum</span>()<br>mp.mean()<br>np.std() <span class="hljs-comment"># 标准差函数</span><br>np.var()<br>np.average()<br>np.prod() <span class="hljs-comment"># 所有元素的乘积</span><br>np.cumsum() <span class="hljs-comment"># 从0开始的元素累加</span><br>np.cumprod() <span class="hljs-comment"># 从1开始的元素累积</span><br>np.median()<br>np.argmax() / np.argmin() <span class="hljs-comment"># 输出索引位置</span><br><span class="hljs-comment"># 有缺失值时</span><br>np.nansum()  np.nanmean()<br></code></pre></td></tr></table></figure><h3 id="8-布尔型数组"><a href="#8-布尔型数组" class="headerlink" title="8.布尔型数组"></a>8.布尔型数组</h3><h4 id="创建布尔型数组"><a href="#创建布尔型数组" class="headerlink" title="创建布尔型数组"></a>创建布尔型数组</h4><p>用普通数组与数比较大小产生</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">arr3 = arr1&gt;<span class="hljs-number">3</span><br><br><span class="hljs-comment"># and:&amp;</span><br><span class="hljs-comment"># or:|</span><br><span class="hljs-comment"># not:~</span><br>np.<span class="hljs-built_in">sum</span>() <span class="hljs-comment"># 统计true的数量</span><br>np.<span class="hljs-built_in">any</span>() <span class="hljs-comment"># 有一个true则返回true</span><br>np.<span class="hljs-built_in">all</span>() <span class="hljs-comment"># 全为true则返回true</span><br></code></pre></td></tr></table></figure><h4 id="布尔型数组作为掩码"><a href="#布尔型数组作为掩码" class="headerlink" title="布尔型数组作为掩码"></a>布尔型数组作为掩码</h4><p>普通数组与布尔型数组维度相同，可以将布尔型数组作为普通数组的掩码。这样可以对普通数组中的元素作筛选。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr3 = arr1&gt;<span class="hljs-number">3</span> <span class="hljs-comment"># arr3为布尔型数组</span><br>arr4 = arr1[arr3] <span class="hljs-comment"># 输出为arr1&gt;4的元素</span><br></code></pre></td></tr></table></figure><p><strong>注：矩阵进行掩码操作后,退化为了向量</strong></p><h4 id="满足条件的元素所在位置及修改-np-where"><a href="#满足条件的元素所在位置及修改-np-where" class="headerlink" title="满足条件的元素所在位置及修改  np.where()"></a>满足条件的元素所在位置及修改  <code>np.where()</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># np.where()输出元素的索引,返回两个值,第一个是索引值，第二个是数据类型</span><br>np.where(arr1&gt;<span class="hljs-number">3</span>)[<span class="hljs-number">0</span>] <span class="hljs-comment"># 只输出索引值</span><br>np.where(arr1&gt;<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) <span class="hljs-comment"># 将arr1&gt;3的赋值1，其余为0 </span><br></code></pre></td></tr></table></figure><h4 id="9-从数组到张量"><a href="#9-从数组到张量" class="headerlink" title="9.从数组到张量"></a>9.从数组到张量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 相互转换</span><br>ts = torch.tensor(arr)<br>arr = np.array(ts)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/sjxwd/my_blog_picture@main/img/image-20240321160704516.png" alt="PyTorch修正NumPy函数或方法"></p><p> <strong>声明：以上图及部分内容来自b站up主[“爆肝杰哥”](<a href="https://space.bilibili.com/358229576">爆肝杰哥的个人空间-爆肝杰哥个人主页-哔哩哔哩视频 (bilibili.com)</a>)</strong></p>]]></content>
    
    
    <categories>
      
      <category>NumPy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NumPy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>短诗句收藏</title>
    <link href="/2024/03/15/%E7%9F%AD%E8%AF%97%E5%8F%A5%E6%94%B6%E8%97%8F/"/>
    <url>/2024/03/15/%E7%9F%AD%E8%AF%97%E5%8F%A5%E6%94%B6%E8%97%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>《来如风雨，去似微尘》</strong></p><p><strong>【适用主题】</strong></p><p>珍惜时光、对生命意义的思考等。</p><p><strong>【释义】</strong></p><p>出自《增广贤文》，意思为：人生短暂，来的时候像风雨匆忙，去的时候又如微尘一样寂静无声。</p><p><strong>02</strong></p><p><strong>《希君生羽翼，一化北溟鱼》</strong></p><p><strong>【适用主题】</strong></p><p>表达美好祝愿，对未来的期许等。</p><p><strong>【适用主题】</strong></p><p>出自李白《江夏使君叔席上赠史郎中》，意思是祝愿你无畏前路艰险，沉潜于海，有朝一日终能张开巨大羽翼，向着光和梦想飞翔。</p><p><img src="https://pic2.zhimg.com/v2-b41b334c05cd8ac44a1c62e395b4f790_720w.jpg?source=d16d100b"></p><p><strong>03</strong></p><p><strong>《人间有味是清欢》</strong></p><p><strong>【适用主题】</strong></p><p>平淡的幸福，从容有度的生活等。</p><p><strong>【适用主题】</strong></p><p>出自苏轼的《浣溪沙·细雨斜风作晓寒》，意思是生活中一些清馨淡雅的时刻，才是最有味道的人生。</p><p><strong>04</strong></p><p><strong>《浮舟沧海，立马昆仑》</strong></p><p><strong>【适用主题】</strong></p><p>气魄雄健，豪情奔放，为中国崛起而奋斗等。</p><p><strong>【释义】</strong></p><p>传承出自周恩来的一副自勉联，意思在大海上划船，在昆仑山处立马。可用来比喻青年们胸怀大志、报效祖国的热忱。</p><p><img src="https://pic3.zhimg.com/v2-c93590b38851487a868fb67add4358f1_720w.jpg?source=d16d100b"></p><p><strong>05</strong></p><p><strong>《青春须早为，岂能长少年》</strong></p><p><strong>【适用主题】</strong></p><p>回忆青春，珍惜时光，奋发有为等。</p><p><strong>【释义】</strong></p><p>出自孟郊的《劝学》，意为：青春年少时期就应趁早努力，一个人难道能够永远都是“少年”吗？</p><p><strong>06</strong></p><p><strong>《红日初升，其道大光》</strong></p><p><strong>【适用主题】</strong></p><p>自立自强、描写国家变化等。</p><p><strong>【释义】</strong></p><p>来源于梁启超的《少年中国说》，意思是：红日刚刚升起，道路充满霞光。可用来指光明的前程，青年的蓬勃朝气。</p><p><img src="https://pic3.zhimg.com/v2-46a0651c37915354de0f7a8ca3af647b_720w.jpg?source=d16d100b"></p><p><strong>07</strong></p><p><strong>《吹灭读书灯，一身都是月》</strong></p><p><strong>【适用主题】</strong></p><p>读书状态的静谧安宁，诗意的生活等。</p><p><strong>【释义】</strong></p><p>桂苓曾在《吹灭读书灯》中写下这句话，意为读书至深夜，将灯吹灭后，就只有月亮陪伴了。</p><p><strong>08</strong></p><p><strong>《落花无言，人淡如菊》</strong></p><p><strong>【适用主题】</strong></p><p>随遇而安，淡泊宁静；行到水穷处，坐看云起时的从容等。</p><p><strong>【释义】</strong></p><p>出自唐代司空图所著的《诗品二十四则·典雅》，大意为：花片轻落，默默无语，幽人恬淡，宛如秋菊。落花无言是经过沧桑波折后的了然：成败宛如花一般，绚烂时是积蓄的必然，凋谢时亦是自然的选择。这是对人生起落的淡定和从容——落花无言而有言，人淡如菊心亦素。</p><p><img src="https://pica.zhimg.com/v2-dae6ea64140290b87ab76ea20249dd3b_720w.jpg?source=d16d100b"></p><p><strong>09</strong></p><p><strong>《且将新火试新茶，诗酒趁年华》</strong></p><p><strong>【适用主题】</strong></p><p>活在当下，乐观积极的人生态度等。</p><p><strong>【释义】</strong></p><p>出自苏轼《望江南·超然台作》，意思为：姑且点上新火来烹煮一杯刚采的新茶，作诗醉酒都要趁年华尚在啊。</p><p><strong>10</strong></p><p><strong>《岁月失语，惟石能言》</strong></p><p><strong>【适用主题】</strong></p><p>有关文化传承，文化保护，珍重历史等。</p><p><strong>【释义】</strong></p><p>出自冯骥才。“岁月失语”，意为岁月悄然流逝，仿佛是一个失忆者，对过去只字不提。“惟石能言”，“石”不仅指的是贺兰山岩画，也是历史留给我们的各种名胜古迹、传统技艺和民族精神，他们都是历史的载体，是历史的最佳发言人。</p><p><strong>11</strong></p><p><strong>《凡是过去，皆为序章》</strong></p><p><strong>【适用主题】</strong></p><p>规劝人们不必沉溺于过去的悲伤，也不要沉溺于过去的美好，活在当下。</p><p><strong>【释义】</strong></p><p>原句出自于莎士比亚戏剧《暴风雨》：What’s past is prologue.无论过去如何，那都只不过是人生的前奏，不必沉溺其中，当下才是人生真正的开始，人生新的篇章将在此刻开始谱写。</p><p><strong>12</strong></p><p><strong>《以痛吻我，报之以歌》</strong></p><p><strong>【适用主题】</strong></p><p>关于豁达乐观的心态、满怀希望地面对挫折与困难、宽容与释怀、痛斥反社会倾向的行为等。</p><p><strong>【释义】</strong></p><p>化用自泰戈尔的“世界吻我以痛，要我报之以歌。”意思是人活在这个世上，少不了伤痛和泪水，但我们能用一种包容豁达的态度，笑对苦累，一路高歌。</p><p><img src="https://pic3.zhimg.com/v2-9af8052053c10dcdf66f04f7ae2145c1_720w.jpg?source=d16d100b"></p><p><strong>13</strong></p><p><strong>《青山一道同风雨》</strong></p><p><strong>【适用主题】</strong></p><p>同甘共苦的情谊，小如友情、亲情；大如家国情，国与国之间的友谊。</p><p><strong>【释义】</strong></p><p>出自王昌龄的《送柴侍御》，原句为：青山一道同云雨， 明月何曾是两乡。意思为：你我一路相连的青山共沐风雨，同顶一轮明月又何曾身处两地呢？</p>]]></content>
    
    
    <categories>
      
      <category>诗词</category>
      
    </categories>
    
    
    <tags>
      
      <tag>诗词</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
